{"/home/travis/build/npmtest/node-npmtest-amqp/test.js":"/* istanbul instrument in package npmtest_amqp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-amqp/lib.npmtest_amqp.js":"/* istanbul instrument in package npmtest_amqp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_amqp = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_amqp = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-amqp/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-amqp && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_amqp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_amqp\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_amqp.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_amqp.rollup.js'] =\n            local.assetsDict['/assets.npmtest_amqp.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_amqp.__dirname +\n                    '/lib.npmtest_amqp.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-amqp/amqp/amqp.js":"'use strict';\nvar Connection = require('./lib/connection');\n    \nmodule.exports = {\n  Connection: Connection,\n  createConnection: function (options, implOptions, readyCallback) {\n    var c = new Connection(options, implOptions, readyCallback);\n    c.connect();\n    return c;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-amqp/amqp/lib/connection.js":"'use strict';\nvar net = require('net');\nvar tls = require('tls');\nvar fs = require('fs');\nvar URL = require('url');\nvar _ = require('lodash');\nvar debug = require('./debug');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar serializer = require('./serializer');\nvar definitions = require('./definitions');\nvar methods = definitions.methods;\nvar methodTable = definitions.methodTable;\nvar classes = definitions.classes;\nvar Exchange = require('./exchange');\nvar Queue = require('./queue');\nvar AMQPParser = require('./parser');\nvar nodeAMQPVersion = require('../package').version;\n\nvar maxFrameBuffer = 131072; // 128k, same as rabbitmq (which was\n                             // copying qpid)\nvar channelMax = 65535;\nvar defaultPorts = { 'amqp': 5672, 'amqps': 5671 };\n\nvar defaultOptions = {\n  host: 'localhost',\n  port: defaultPorts['amqp'],\n  login: 'guest',\n  password: 'guest',\n  authMechanism: 'AMQPLAIN',\n  vhost: '/',\n  connectionTimeout: 10000,\n  ssl: {\n    enabled: false\n  }\n};\n\nvar defaultSslOptions = {\n  port: defaultPorts['amqps'],\n  ssl: {\n    rejectUnauthorized: true\n  }\n};\n\nvar defaultImplOptions = {\n  defaultExchangeName: '',\n  reconnect: true,\n  reconnectBackoffStrategy: 'linear',\n  reconnectExponentialLimit: 120000,\n  reconnectBackoffTime: 1000\n};\n\nvar defaultClientProperties = {\n  version: nodeAMQPVersion,\n  platform: 'node-' + process.version,\n  product: 'node-amqp'\n};\n\nvar Connection = module.exports = function Connection (connectionArgs, options, readyCallback) {\n  EventEmitter.call(this);\n  this.setOptions(connectionArgs);\n  this.setImplOptions(options);\n\n  if (typeof readyCallback === 'function') {\n    this._readyCallback = readyCallback;\n  }\n\n  this.connectionAttemptScheduled = false;\n  this._defaultExchange = null;\n  this.channelCounter = 0;\n  this._sendBuffer = new Buffer(maxFrameBuffer);\n\n  this._blocked = false;\n  this._blockedReason = null;\n};\nutil.inherits(Connection, EventEmitter);\n\n\n\nConnection.prototype.setOptions = function (options) {\n  var urlo = (options && options.url) ? this._parseURLOptions(options.url) : {};\n  var sslo = (options && options.ssl && options.ssl.enabled) ? defaultSslOptions : {};\n  this.options = _.assignIn({}, defaultOptions, sslo, urlo, options || {});\n  this.options.clientProperties =  _.assignIn({}, defaultClientProperties, (options && options.clientProperties) || {});\n};\n\nConnection.prototype.setImplOptions = function (options) {\n  this.implOptions = _.assignIn({}, defaultImplOptions, options || {});\n};\n\nConnection.prototype.connect = function () {\n  // If this is our first connection, add listeners.\n  if (!this.socket) this.addAllListeners();\n\n  this._createSocket();\n  this._startHandshake();\n};\n\nConnection.prototype.reconnect = function () {\n  // Suspend activity on channels\n  for (var channel in this.channels) {\n    this.channels[channel].state = 'closed';\n  }\n  debug && debug(\"Connection lost, reconnecting...\");\n  // Terminate socket activity\n  if (this.socket) this.socket.end();\n  this.connect();\n};\n\nConnection.prototype.disconnect = function () {\n  debug && debug(\"Sending disconnect request to server\");\n  this._sendMethod(0, methods.connectionClose, {\n    'replyText': 'client disconnect',\n    'replyCode': 200,\n    'classId': 0,\n    'methodId': 0\n  });\n};\n\nConnection.prototype.addAllListeners = function() {\n  var self = this;\n  var connectEvent = this.options.ssl.enabled ? 'secureConnect' : 'connect';\n\n\n  self.addListener(connectEvent, function() {\n    // In the case where this is a reconnection, do not trample on the existing\n    // channels.\n    // For your reference, channel 0 is the control channel.\n    self.channels = self.channels || {0:self};\n    self.queues = self.queues || {};\n    self.exchanges = self.exchanges || {};\n\n    self.parser = new AMQPParser('0-9-1', 'client');\n\n    self.parser.onMethod = function (channel, method, args) {\n      self._onMethod(channel, method, args);\n    };\n\n    self.parser.onContent = function (channel, data) {\n      debug && debug(channel + \" > content \" + data.length);\n      if (self.channels[channel] && self.channels[channel]._onContent) {\n        self.channels[channel]._onContent(channel, data);\n      } else {\n        debug && debug(\"unhandled content: \" + data);\n      }\n    };\n\n    self.parser.onContentHeader = function (channel, classInfo, weight, properties, size) {\n      debug && debug(channel + \" > content header \" + JSON.stringify([classInfo.name, weight, properties, size]));\n      if (self.channels[channel] && self.channels[channel]._onContentHeader) {\n        self.channels[channel]._onContentHeader(channel, classInfo, weight, properties, size);\n      } else {\n        debug && debug(\"unhandled content header\");\n      }\n    };\n\n    self.parser.onHeartBeat = function () {\n      self.emit(\"heartbeat\");\n      debug && debug(\"heartbeat\");\n    };\n\n    self.parser.onError = function (e) {\n      self.emit(\"error\", e);\n      self.emit(\"close\");\n    };\n\n    // Remove readyEmitted flag so we can detect an auth error.\n    self.readyEmitted = false;\n  });\n\n  self.addListener('data', function (data) {\n    if(self.parser != null){\n      try {\n        self.parser.execute(data);\n      } catch (exception) {\n        self.emit('error', exception);\n        return;\n      }\n    }\n    self._inboundHeartbeatTimerReset();\n  });\n\n  var backoffTime = null;\n  self.addListener('error', function backoff(e) {\n    if (self._inboundHeartbeatTimer !== null) {\n      clearTimeout(self._inboundHeartbeatTimer);\n      self._inboundHeartbeatTimer = null;\n    }\n    if (self._outboundHeartbeatTimer !== null) {\n      clearTimeout(self._outboundHeartbeatTimer);\n      self._outboundHeartbeatTimer = null;\n    }\n\n    if (!self.connectionAttemptScheduled) {\n      // Set to true, as we are presently in the process of scheduling one.\n      self.connectionAttemptScheduled = true;\n\n      // Kill the socket, if it hasn't been killed already.\n      self.socket.end();\n\n      // Reset parser state\n      self.parser = null;\n\n      // In order for our reconnection to be seamless, we have to notify the\n      // channels that they are no longer connected so that nobody attempts\n      // to send messages which would be doomed to fail.\n      for (var channel in self.channels) {\n        if (channel !== '0') {\n          self.channels[channel].state = 'closed';\n        }\n      }\n      // Queues are channels (so we have already marked them as closed), but\n      // queues have special needs, since the subscriptions will no longer\n      // be known to the server when we reconnect.  Mark the subscriptions as\n      // closed so that we can resubscribe them once we are reconnected.\n      for (var queue in self.queues) {\n        for (var index in self.queues[queue].consumerTagOptions) {\n          self.queues[queue].consumerTagOptions[index]['state'] = 'closed';\n        }\n      }\n\n      // Begin reconnection attempts\n      if (self.implOptions.reconnect) {\n        // Don't thrash, use a backoff strategy.\n        if (backoffTime === null) {\n          // This is the first time we've failed since a successful connection,\n          // so use the configured backoff time without any modification.\n          backoffTime = self.implOptions.reconnectBackoffTime;\n        } else if (self.implOptions.reconnectBackoffStrategy === 'exponential') {\n          // If you've configured exponential backoff, we'll double the\n          // backoff time each subsequent attempt until success.\n          backoffTime *= 2;\n          // limit the maxium timeout, to avoid potentially unlimited stalls\n          if(backoffTime > self.implOptions.reconnectExponentialLimit){\n            backoffTime = self.implOptions.reconnectExponentialLimit;\n          }\n\n        } else if (self.implOptions.reconnectBackoffStrategy === 'linear') {\n          // Linear strategy is the default.  In this case, we will retry at a\n          // constant interval, so there's no need to change the backoff time\n          // between attempts.\n        } else {\n          // TODO should we warn people if they picked a nonexistent strategy?\n        }\n\n        setTimeout(function () {\n          // Set to false, so that if we fail in the reconnect attempt, we can\n          // schedule another one.\n          self.connectionAttemptScheduled = false;\n          self.reconnect();\n        }, backoffTime);\n      } else {\n        self.removeListener('error', backoff);\n      }\n    }\n  });\n\n  self.addListener('ready', function () {\n    // Reset the backoff time since we have successfully connected.\n    backoffTime = null;\n\n    if (self.implOptions.reconnect) {\n      // Reconnect any channels which were open.\n      _.forEach(self.channels, function(channel, index) {\n        if (index !== '0') channel.reconnect();\n      });\n    }\n\n    // Set 'ready' flag for auth failure detection.\n    this.readyEmitted = true;\n\n    // Restart the heartbeat to the server\n    self._outboundHeartbeatTimerReset();\n  });\n\n  // Apparently, it is not possible to determine if an authentication error\n  // has occurred, but when the connection closes then we can HINT that a\n  // possible authentication error has occured.  Although this may be a bug\n  // in the spec, handling it as a possible error is considerably better than\n  // failing silently.\n  self.addListener('end', function (){\n    if (!this.readyEmitted){\n      this.emit('error', new Error(\n        'Connection ended: possibly due to an authentication failure.'\n      ));\n    }\n  });\n};\n\nConnection.prototype.heartbeat = function () {\n  if(this.socket.writable) this.write(new Buffer([8,0,0,0,0,0,0,206]));\n};\n\n// connection.exchange('my-exchange', { type: 'topic' });\n// Options\n// - type 'fanout', 'direct', or 'topic' (default)\n// - passive (boolean)\n// - durable (boolean)\n// - autoDelete (boolean, default true)\nConnection.prototype.exchange = function (name, options, openCallback) {\n  if (name === undefined) name = this.implOptions.defaultExchangeName;\n\n  if (!options) options = {};\n  if (name !== '' && options.type === undefined) options.type = 'topic';\n\n  try{\n    var channel = this.generateChannelId();\n  }catch(exception){\n    this.emit(\"error\", exception);\n    return;\n  }\n  var exchange = new Exchange(this, channel, name, options, openCallback);\n  this.channels[channel] = exchange;\n  this.exchanges[name] = exchange;\n  return exchange;\n};\n\n// remove an exchange when it's closed (called from Exchange)\nConnection.prototype.exchangeClosed = function (name) {\n  if (this.exchanges[name]) delete this.exchanges[name];\n};\n\n// Options\n// - passive (boolean)\n// - durable (boolean)\n// - exclusive (boolean)\n// - autoDelete (boolean, default true)\nConnection.prototype.queue = function (name /* options, openCallback */) {\n  var options, callback;\n  if (typeof arguments[1] == 'object') {\n    options = arguments[1];\n    callback = arguments[2];\n  } else {\n    callback = arguments[1];\n  }\n\n  try{\n    var channel = this.generateChannelId();\n  }catch(exception){\n    this.emit(\"error\", exception);\n    return;\n  }\n\n  var q = new Queue(this, channel, name, options, callback);\n  this.channels[channel] = q;\n  return q;\n};\n\n// remove a queue when it's closed (called from Queue)\nConnection.prototype.queueClosed = function (name) {\n  if (this.queues[name]) delete this.queues[name];\n};\n\n// Publishes a message to the default exchange.\nConnection.prototype.publish = function (routingKey, body, options, callback) {\n  if (!this._defaultExchange) {\n    this._defaultExchange = this.exchange();\n  }\n\n  var exchange = this._defaultExchange;\n  if (exchange.state === 'open') {\n    exchange.publish(routingKey, body, options, callback);\n  } else {\n    exchange.once('open', function() {\n      exchange.publish(routingKey, body, options, callback);\n    });\n  }\n};\n\nConnection.prototype._bodyToBuffer = function (body) {\n  // Handles 3 cases\n  // - body is utf8 string\n  // - body is instance of Buffer\n  // - body is an object and its JSON representation is sent\n  // Does not handle the case for streaming bodies.\n  // Returns buffer.\n  if (typeof(body) == 'string') {\n    return [null, new Buffer(body, 'utf8')];\n  } else if (body instanceof Buffer) {\n    return [null, body];\n  } else {\n    var jsonBody = JSON.stringify(body);\n\n    debug && debug('sending json: ' + jsonBody);\n\n    var props = {contentType: 'application/json'};\n    return [props, new Buffer(jsonBody, 'utf8')];\n  }\n};\n\nConnection.prototype._inboundHeartbeatTimerReset = function () {\n  if (this._inboundHeartbeatTimer !== null) {\n    clearTimeout(this._inboundHeartbeatTimer);\n    this._inboundHeartbeatTimer = null;\n  }\n  if (this.options.heartbeat) {\n    var self = this;\n    var gracePeriod = 2 * this.options.heartbeat;\n    this._inboundHeartbeatTimer = setTimeout(function () {\n      if(self.socket.readable || self.options.heartbeatForceReconnect){\n        self.emit('error', new Error('no heartbeat or data in last ' + gracePeriod + ' seconds'));\n      }\n    }, gracePeriod * 1000);\n  }\n};\n\nConnection.prototype._outboundHeartbeatTimerReset = function () {\n  if (this._outboundHeartbeatTimer !== null) {\n    clearTimeout(this._outboundHeartbeatTimer);\n    this._outboundHeartbeatTimer = null;\n  }\n  if (this.socket.writable && this.options.heartbeat) {\n    var self = this;\n    this._outboundHeartbeatTimer = setTimeout(function () {\n      self.heartbeat();\n      self._outboundHeartbeatTimerReset();\n    }, 1000 * this.options.heartbeat);\n  }\n};\n\nConnection.prototype._saslResponse = function () {\n  var response;\n  if (this.options.authMechanism == 'AMQPLAIN')\n    response = {\n      LOGIN: this.options.login,\n      PASSWORD: this.options.password\n    };\n  else if (this.options.authMechanism == 'PLAIN')\n    response = \"\\0\" + this.options.login + \"\\0\" + this.options.password;\n  else if (this.options.authMechanism == 'EXTERNAL')\n    response = \"\\0\";\n  else if (this.options.authMechanism == 'ANONYMOUS')\n    response = \"\\0\";\n  else\n    response = this.options.response;\n\n  return response;\n}\n\nConnection.prototype._onMethod = function (channel, method, args) {\n  debug && debug(channel + \" > \" + method.name + \" \" + JSON.stringify(args));\n\n  // Channel 0 is the control channel. If not zero then delegate to\n  // one of the channel objects.\n\n  if (channel > 0) {\n    if (!this.channels[channel]) {\n      debug && debug(\"Received message on untracked channel.\");\n      return;\n    }\n    if (!this.channels[channel]._onChannelMethod) {\n      throw new Error('Channel ' + channel + ' has no _onChannelMethod method.');\n    }\n    this.channels[channel]._onChannelMethod(channel, method, args);\n    return;\n  }\n\n  // channel 0\n\n  switch (method) {\n    // 2. The server responds, after the version string, with the\n    // 'connectionStart' method (contains various useless information)\n    case methods.connectionStart:\n      // We check that they're serving us AMQP 0-9\n      if (args.versionMajor !== 0 && args.versionMinor != 9) {\n        this.socket.end();\n        this.emit('error', new Error(\"Bad server version\"));\n        return;\n      }\n      this.serverProperties = args.serverProperties;\n      // 3. Then we reply with StartOk, containing our useless information.\n      this._sendMethod(0, methods.connectionStartOk, {\n        clientProperties: this.options.clientProperties,\n        mechanism: this.options.authMechanism,\n        response: this._saslResponse(),\n        locale: 'en_US'\n      });\n      break;\n\n    // 4. The server responds with a connectionTune request\n    case methods.connectionTune:\n      if (args.frameMax) {\n          debug && debug(\"tweaking maxFrameBuffer to \" + args.frameMax);\n          maxFrameBuffer = args.frameMax;\n          this._sendBuffer = new Buffer(maxFrameBuffer);\n          this.parser.setMaxFrameBuffer(maxFrameBuffer);\n      }\n      if (args.channelMax) {\n          debug && debug(\"tweaking channelMax to \" + args.channelMax);\n          channelMax = args.channelMax;\n      }\n      // 5. We respond with connectionTuneOk\n      this._sendMethod(0, methods.connectionTuneOk, {\n        channelMax: channelMax,\n        frameMax: maxFrameBuffer,\n        heartbeat: this.options.heartbeat || 0\n      });\n      // 6. Then we have to send a connectionOpen request\n      this._sendMethod(0, methods.connectionOpen, {\n        virtualHost: this.options.vhost\n        // , capabilities: ''\n        // , insist: true\n        ,\n        reserved1: '',\n        reserved2: true\n      });\n      break;\n\n\n    case methods.connectionOpenOk:\n      // 7. Finally they respond with connectionOpenOk\n      // Whew! That's why they call it the Advanced MQP.\n      if (this._readyCallback) {\n        this._readyCallback(this);\n        this._readyCallback = null;\n      }\n      this.emit('ready');\n      break;\n\n    case methods.connectionClose:\n      var e = new Error(args.replyText);\n      e.code = args.replyCode;\n      if (!this.listeners('close').length) {\n        console.log('Unhandled connection error: ' + args.replyText);\n      }\n      this.socket.destroy(e);\n      break;\n\n    case methods.connectionCloseOk:\n      debug && debug(\"Received close-ok from server, closing socket\");\n      this.socket.end();\n      break;\n\n    case methods.connectionBlocked:\n      debug && debug('Received connection.blocked from server with reason: ' + args.reason);\n      this._blocked = true;\n      this._blockedReason = args.reason;\n      this.emit('blocked');\n      break;\n\n    case methods.connectionUnblocked:\n      debug && debug('Received connection.unblocked from server');\n      this._blocked = false;\n      this._blockedReason = null;\n      this.emit('unblocked');\n      break;\n\n    default:\n      throw new Error(\"Uncaught method '\" + method.name + \"' with args \" +\n          JSON.stringify(args));\n  }\n};\n\n// Generate connection options from URI string formatted with amqp scheme.\nConnection.prototype._parseURLOptions = function(connectionString) {\n  var opts = {};\n  opts.ssl = {};\n  var url = URL.parse(connectionString);\n  var scheme = url.protocol.substring(0, url.protocol.lastIndexOf(':'));\n  if (scheme != 'amqp' && scheme != 'amqps') {\n    throw new Error('Connection URI must use amqp or amqps scheme. ' +\n                    'For example, \"amqp://bus.megacorp.internal:5766\".');\n  }\n  opts.ssl.enabled = ('amqps' === scheme);\n  opts.host = url.hostname;\n  opts.port = url.port || defaultPorts[scheme];\n  if (url.auth) {\n    var auth = url.auth.split(':');\n    auth[0] && (opts.login = auth[0]);\n    auth[1] && (opts.password = auth[1]);\n  }\n  if (url.pathname) {\n    opts.vhost = unescape(url.pathname.substr(1));\n  }\n  return opts;\n};\n\n/*\n *\n * Connect helpers\n *\n */\n\n// If you pass a array of hosts, lets choose a random host or the preferred host number, or then next one.\nConnection.prototype._chooseHost = function() {\n  if(Array.isArray(this.options.host)){\n    if(this.hosti == null){\n      if(typeof this.options.hostPreference == 'number') {\n        this.hosti = (this.options.hostPreference < this.options.host.length) ?\n          this.options.hostPreference : this.options.host.length-1;\n      } else {\n        this.hosti = parseInt(Math.random() * this.options.host.length, 10);\n      }\n    } else {\n      // If this is already set, it looks like we want to choose another one.\n      // Add one to hosti but don't overflow it.\n      this.hosti = (this.hosti + 1) % this.options.host.length;\n    }\n    return this.options.host[this.hosti];\n  } else {\n    return this.options.host;\n  }\n};\n\nConnection.prototype._createSocket = function() {\n  var hostName = this._chooseHost(), self = this, port = this.options.port;\n  var parsedHost = URL.parse(hostName);\n  if(parsedHost.port){\n    hostName = parsedHost.hostname;\n    port = parsedHost.port;\n  }\n\n  var options = {\n    port: port,\n    host: hostName\n  };\n\n  // Disable tcp nagle's algo\n  // Default: true, makes small messages faster\n  var noDelay = this.options.noDelay || true;\n\n  var resetConnectionTimeout = function () {\n    debug && debug('connected so resetting connection timeout');\n    this.setTimeout(0);\n  };\n\n  // Connect socket\n  if (this.options.ssl.enabled) {\n    debug && debug('making ssl connection');\n    options = _.assignIn(options, this._getSSLOptions());\n    this.socket = tls.connect(options, resetConnectionTimeout);\n  } else {\n    debug && debug('making non-ssl connection');\n    this.socket = net.connect(options, resetConnectionTimeout);\n  }\n  var connTimeout = this.options.connectionTimeout;\n  if (connTimeout) {\n    debug && debug('setting connection timeout to ' + connTimeout);\n    this.socket.setTimeout(connTimeout, function () {\n      debug && debug('connection timeout');\n      this.destroy();\n      var e = new Error('connection timeout');\n      e.name = 'TimeoutError';\n      self.emit('error', e);\n    });\n  }\n\n  this.socket.setNoDelay(noDelay);\n\n  // Proxy events.\n  // Note that if we don't attach a 'data' event, no data will flow.\n  var events = ['close', 'connect', 'data', 'drain', 'error', 'end', 'secureConnect', 'timeout'];\n  _.forEach(events, function(event){\n    self.socket.on(event, self.emit.bind(self, event));\n  });\n\n  // Proxy a few methods that we use / previously used.\n  var methods = ['destroy', 'write', 'pause', 'resume', 'setEncoding', 'ref', 'unref', 'address'];\n  _.forEach(methods, function(method){\n    self[method] = function(){\n      self.socket[method].apply(self.socket, arguments);\n    };\n  });\n};\n\nConnection.prototype.end = function() {\n  if (this.socket) {\n    this.socket.end();\n  }\n\n  this.options.heartbeat = false;\n\n  if (this._inboundHeartbeatTimer !== null) {\n    clearTimeout(this._inboundHeartbeatTimer);\n    this._inboundHeartbeatTimer = null;\n  }\n\n  if (this._outboundHeartbeatTimer !== null) {\n    clearTimeout(this._outboundHeartbeatTimer);\n    this._outboundHeartbeatTimer = null;\n  }\n};\n\nConnection.prototype._getSSLOptions = function() {\n  if (this.sslConnectionOptions) return this.sslConnectionOptions;\n  this.sslConnectionOptions = {};\n\n  if (this.options.ssl.pfxFile) {\n    this.sslConnectionOptions.pfx = fs.readFileSync(this.options.ssl.pfxFile);\n  }\n  if (this.options.ssl.keyFile) {\n    this.sslConnectionOptions.key = fs.readFileSync(this.options.ssl.keyFile);\n  }\n  if (this.options.ssl.certFile) {\n    this.sslConnectionOptions.cert = fs.readFileSync(this.options.ssl.certFile);\n  }\n  if (this.options.ssl.caFile) {\n    if (Array.isArray(this.options.ssl.caFile)) {\n      this.sslConnectionOptions.ca = this.options.ssl.caFile.map(function(f){\n        return fs.readFileSync(f);\n      });\n    } else {\n      this.sslConnectionOptions.ca = fs.readFileSync(this.options.ssl.caFile);\n    }\n  }\n\n  this.sslConnectionOptions.rejectUnauthorized = this.options.ssl.rejectUnauthorized;\n  this.sslConnectionOptions.passphrase = this.options.ssl.passphrase;\n\n  return this.sslConnectionOptions;\n};\n\n// Time to start the AMQP 7-way connection initialization handshake!\n// 1. The client sends the server a version string\nConnection.prototype._startHandshake = function() {\n  debug && debug(\"Initiating handshake...\");\n  this.write(\"AMQP\" + String.fromCharCode(0,0,9,1));\n};\n\n/*\n *\n * Parse helpers\n *\n */\n\nConnection.prototype._sendBody = function (channel, body, properties) {\n  var r = this._bodyToBuffer(body);\n  var props = r[0], buffer = r[1];\n\n  properties = _.assignIn(props || {}, properties);\n\n  this._sendHeader(channel, buffer.length, properties);\n\n  var pos = 0, len = buffer.length;\n  var metaSize = 8; // headerBytes = 7, frameEndBytes = 1\n  var maxBodySize = maxFrameBuffer - metaSize;\n\n  while (len > 0) {\n    var bodySize = len < maxBodySize ? len : maxBodySize;\n    var frameSize = bodySize + metaSize;\n\n    var b = new Buffer(frameSize);\n    b.used = 0;\n    b[b.used++] = 3; // constants.frameBody\n    serializer.serializeInt(b, 2, channel);\n    serializer.serializeInt(b, 4, bodySize);\n    buffer.copy(b, b.used, pos, pos+bodySize);\n    b.used += bodySize;\n    b[b.used++] = 206; // constants.frameEnd;\n    this.write(b);\n\n    len -= bodySize;\n    pos += bodySize;\n  }\n  return;\n};\n\n// connection: the connection\n// channel: the channel to send this on\n// size: size in bytes of the following message\n// properties: an object containing any of the following:\n// - contentType (default 'application/octet-stream')\n// - contentEncoding\n// - headers\n// - deliveryMode\n// - priority (0-9)\n// - correlationId\n// - replyTo\n// - expiration\n// - messageId\n// - timestamp\n// - userId\n// - appId\n// - clusterId\nConnection.prototype._sendHeader = function(channel, size, properties) {\n  var b = new Buffer(maxFrameBuffer); // FIXME allocating too much.\n                                      // use freelist?\n  b.used = 0;\n\n  var classInfo = classes[60]; // always basic class.\n\n  // 7 OCTET FRAME HEADER\n\n  b[b.used++] = 2; // constants.frameHeader\n\n  serializer.serializeInt(b, 2, channel);\n\n  var lengthStart = b.used;\n\n  serializer.serializeInt(b, 4, 0 /*dummy*/); // length\n\n  var bodyStart = b.used;\n\n  // HEADER'S BODY\n\n  serializer.serializeInt(b, 2, classInfo.index);   // class 60 for Basic\n  serializer.serializeInt(b, 2, 0);                 // weight, always 0 for rabbitmq\n  serializer.serializeInt(b, 8, size);              // byte size of body\n\n  // properties - first propertyFlags\n  properties = _.defaults(properties || {}, {contentType: 'application/octet-stream'});\n  var propertyFlags = 0;\n  for (var i = 0; i < classInfo.fields.length; i++) {\n    if (properties[classInfo.fields[i].name]) propertyFlags |= 1 << (15-i);\n  }\n  serializer.serializeInt(b, 2, propertyFlags);\n  // now the actual properties.\n  serializer.serializeFields(b, classInfo.fields, properties, false);\n\n  //serializeTable(b, properties);\n\n  var bodyEnd = b.used;\n\n  // Go back to the header and write in the length now that we know it.\n  b.used = lengthStart;\n  serializer.serializeInt(b, 4, bodyEnd - bodyStart);\n  b.used = bodyEnd;\n\n  // 1 OCTET END\n\n  b[b.used++] = 206; // constants.frameEnd;\n\n  var s = new Buffer(b.used);\n  b.copy(s);\n\n  //debug && debug('header sent: ' + JSON.stringify(s));\n\n  this.write(s);\n};\n\nConnection.prototype._sendMethod = function (channel, method, args) {\n  debug && debug(channel + \" < \" + method.name + \" \" + JSON.stringify(args));\n  var b = this._sendBuffer;\n  b.used = 0;\n\n  b[b.used++] = 1; // constants.frameMethod\n\n  serializer.serializeInt(b, 2, channel);\n\n  var lengthIndex = b.used;\n\n  serializer.serializeInt(b, 4, 42); // replace with actual length.\n\n  var startIndex = b.used;\n\n\n  serializer.serializeInt(b, 2, method.classIndex); // short, classId\n  serializer.serializeInt(b, 2, method.methodIndex); // short, methodId\n\n  serializer.serializeFields(b, method.fields, args, true);\n\n  var endIndex = b.used;\n\n  // write in the frame length now that we know it.\n  b.used = lengthIndex;\n  serializer.serializeInt(b, 4, endIndex - startIndex);\n  b.used = endIndex;\n\n  b[b.used++] = 206; // constants.frameEnd;\n\n  var c = new Buffer(b.used);\n  b.copy(c);\n\n  debug && debug(\"sending frame: \" + c.toJSON());\n\n  this.write(c);\n\n  this._outboundHeartbeatTimerReset();\n};\n\n// tries to find the next available id slot for a channel\nConnection.prototype.generateChannelId = function () {\n  // start from the last used slot id\n  var channelId = this.channelCounter;\n  while(true){\n    // use values in range of 1..65535\n    channelId = channelId % channelMax + 1;\n    if(!this.channels[channelId]){\n      break;\n    }\n    // after a full loop throw an Error\n    if(channelId == this.channelCounter){\n      throw new Error(\"No valid Channel Id values available\");\n    }\n  }\n  this.channelCounter = channelId;\n  return this.channelCounter;\n};\n","/home/travis/build/npmtest/node-npmtest-amqp/amqp/lib/debug.js":"'use strict';\n\nvar DEBUG = process.env['NODE_DEBUG_AMQP'];\n\n// only define debug function in debugging mode\nif (DEBUG) {\n  module.exports = function debug () {\n    console.error.apply(null, arguments);\n  };\n} else {\n  module.exports = null;\n}\n\n","/home/travis/build/npmtest/node-npmtest-amqp/amqp/lib/serializer.js":"'use strict';\n\nvar jspack = require('../jspack').jspack;\n\nvar serializer = module.exports = {\n  serializeFloat: function(b, size, value, bigEndian) {\n    var jp = new jspack(bigEndian);\n\n    switch(size) {\n      case 4:\n        var x = jp.Pack('f', [value]);\n        for (var i = 0; i < x.length; ++i)\n          b[b.used++] = x[i];\n        break;\n\n      case 8:\n        var x = jp.Pack('d', [value]);\n        for (var i = 0; i < x.length; ++i)\n          b[b.used++] = x[i];\n        break;\n\n      default:\n        throw new Error(\"Unknown floating point size\");\n    }\n  },\n\n  serializeInt: function (b, size, int) {\n    if (b.used + size > b.length) {\n      throw new Error(\"write out of bounds\");\n    }\n\n    // Only 4 cases - just going to be explicit instead of looping.\n\n    switch (size) {\n      // octet\n      case 1:\n        b[b.used++] = int;\n        break;\n\n      // short\n      case 2:\n        b[b.used++] = (int & 0xFF00) >> 8;\n        b[b.used++] = (int & 0x00FF) >> 0;\n        break;\n\n      // long\n      case 4:\n        b[b.used++] = (int & 0xFF000000) >> 24;\n        b[b.used++] = (int & 0x00FF0000) >> 16;\n        b[b.used++] = (int & 0x0000FF00) >> 8;\n        b[b.used++] = (int & 0x000000FF) >> 0;\n        break;\n\n\n      // long long\n      case 8:\n        b[b.used++] = (int & 0xFF00000000000000) >> 56;\n        b[b.used++] = (int & 0x00FF000000000000) >> 48;\n        b[b.used++] = (int & 0x0000FF0000000000) >> 40;\n        b[b.used++] = (int & 0x000000FF00000000) >> 32;\n        b[b.used++] = (int & 0x00000000FF000000) >> 24;\n        b[b.used++] = (int & 0x0000000000FF0000) >> 16;\n        b[b.used++] = (int & 0x000000000000FF00) >> 8;\n        b[b.used++] = (int & 0x00000000000000FF) >> 0;\n        break;\n\n      default:\n        throw new Error(\"Bad size\");\n    }\n  },\n\n\n  serializeShortString: function (b, string) {\n    if (typeof(string) != \"string\") {\n      throw new Error(\"param must be a string\");\n    }\n    var byteLength = Buffer.byteLength(string, 'utf8');\n    if (byteLength > 0xFF) {\n      throw new Error(\"String too long for 'shortstr' parameter\");\n    }\n    if (1 + byteLength + b.used >= b.length) {\n      throw new Error(\"Not enough space in buffer for 'shortstr'\");\n    }\n    b[b.used++] = byteLength;\n    b.write(string, b.used, 'utf8');\n    b.used += byteLength;\n  },\n\n  serializeLongString: function(b, string) {\n    // we accept string, object, or buffer for this parameter.\n    // in the case of string we serialize it to utf8.\n    if (typeof(string) == 'string') {\n      var byteLength = Buffer.byteLength(string, 'utf8');\n      serializer.serializeInt(b, 4, byteLength);\n      b.write(string, b.used, 'utf8');\n      b.used += byteLength;\n    } else if (typeof(string) == 'object') {\n      serializer.serializeTable(b, string);\n    } else {\n      // data is Buffer\n      var byteLength = string.length;\n      serializer.serializeInt(b, 4, byteLength);\n      b.write(string, b.used); // memcpy\n      b.used += byteLength;\n    }\n  },\n\n  serializeDate: function(b, date) {\n    serializer.serializeInt(b, 8, date.valueOf() / 1000);\n  },\n\n  serializeBuffer: function(b, buffer) {\n    serializer.serializeInt(b, 4, buffer.length);\n    buffer.copy(b, b.used, 0);\n    b.used += buffer.length;\n  },\n\n  serializeBase64: function(b, buffer) {\n    serializer.serializeLongString(b, buffer.toString('base64'));\n  },\n\n  isBigInt: function(value) {\n    return value > 0xffffffff;\n  },\n\n  getCode: function(dec) {\n    var hexArray = \"0123456789ABCDEF\".split('');\n    var code1 = Math.floor(dec / 16);\n    var code2 = dec - code1 * 16;\n    return hexArray[code2];\n  },\n\n  isFloat: function(value){\n    return value === +value && value !== (value|0);\n  },\n\n  serializeValue: function(b, value) {\n    switch (typeof(value)) {\n      case 'string':\n        b[b.used++] = 'S'.charCodeAt(0);\n        serializer.serializeLongString(b, value);\n        break;\n\n      case 'number':\n        if (!serializer.isFloat(value)) {\n          if (serializer.isBigInt(value)) {\n            // 64-bit uint\n            b[b.used++] = 'l'.charCodeAt(0);\n            serializer.serializeInt(b, 8, value);\n          } else {\n            //32-bit uint\n            b[b.used++] = 'I'.charCodeAt(0);\n            serializer.serializeInt(b, 4, value);\n          }\n        } else {\n          //64-bit float\n          b[b.used++] = 'd'.charCodeAt(0);\n          serializer.serializeFloat(b, 8, value);\n        }\n        break;\n\n      case 'boolean':\n        b[b.used++] = 't'.charCodeAt(0);\n        b[b.used++] = value;\n        break;\n\n      default:\n        if (value instanceof Date) {\n          b[b.used++] = 'T'.charCodeAt(0);\n          serializer.serializeDate(b, value);\n        } else if (value instanceof Buffer) {\n          b[b.used++] = 'x'.charCodeAt(0);\n          serializer.serializeBuffer(b, value);\n        } else if (Array.isArray(value)) {\n          b[b.used++] = 'A'.charCodeAt(0);\n          serializer.serializeArray(b, value);\n        } else if (typeof(value) === 'object') {\n          b[b.used++] = 'F'.charCodeAt(0);\n          serializer.serializeTable(b, value);\n        } else {\n          throw new Error(\"unsupported type in amqp table: \" + typeof(value));\n        }\n    }\n  },\n\n  serializeTable: function(b, object) {\n    if (typeof(object) != \"object\") {\n      throw new Error(\"param must be an object\");\n    }\n\n    // Save our position so that we can go back and write the length of this table\n    // at the beginning of the packet (once we know how many entries there are).\n    var lengthIndex = b.used;\n    b.used += 4; // sizeof long\n    var startIndex = b.used;\n\n    for (var key in object) {\n      if (!object.hasOwnProperty(key)) continue;\n      serializer.serializeShortString(b, key);\n      serializer.serializeValue(b, object[key]);\n    }\n\n    var endIndex = b.used;\n    b.used = lengthIndex;\n    serializer.serializeInt(b, 4, endIndex - startIndex);\n    b.used = endIndex;\n  },\n\n  serializeArray: function(b, arr) {\n    // Save our position so that we can go back and write the byte length of this array\n    // at the beginning of the packet (once we have serialized all elements).\n    var lengthIndex = b.used;\n    b.used += 4; // sizeof long\n    var startIndex = b.used;\n\n    var len = arr.length;\n    for (var i = 0; i < len; i++) {\n      serializer.serializeValue(b, arr[i]);\n    }\n\n    var endIndex = b.used;\n    b.used = lengthIndex;\n    serializer.serializeInt(b, 4, endIndex - startIndex);\n    b.used = endIndex;\n  },\n\n  serializeFields: function(buffer, fields, args, strict) {\n    var bitField = 0;\n    var bitIndex = 0;\n    for (var i = 0; i < fields.length; i++) {\n      var field = fields[i];\n      var domain = field.domain;\n      if (!(field.name in args)) {\n        if (strict) {\n          throw new Error(\"Missing field '\" + field.name + \"' of type '\" + domain + \"' while executing AMQP method '\" + \n            arguments.callee.caller.arguments[1].name + \"'\");\n        }\n        continue;\n      }\n\n      var param = args[field.name];\n\n      //debug(\"domain: \" + domain + \" param: \" + param);\n\n      switch (domain) {\n        case 'bit':\n          if (typeof(param) != \"boolean\") {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n\n          if (param) bitField |= (1 << bitIndex);\n          bitIndex++;\n\n          if (!fields[i+1] || fields[i+1].domain != 'bit') {\n            //debug('SET bit field ' + field.name + ' 0x' + bitField.toString(16));\n            buffer[buffer.used++] = bitField;\n            bitField = 0;\n            bitIndex = 0;\n          }\n          break;\n\n        case 'octet':\n          if (typeof(param) != \"number\" || param > 0xFF) {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n          buffer[buffer.used++] = param;\n          break;\n\n        case 'short':\n          if (typeof(param) != \"number\" || param > 0xFFFF) {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n          serializer.serializeInt(buffer, 2, param);\n          break;\n\n        case 'long':\n          if (typeof(param) != \"number\" || param > 0xFFFFFFFF) {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n          serializer.serializeInt(buffer, 4, param);\n          break;\n\n        // In a previous version this shared code with 'longlong', which caused problems when passed Date\n        // integers. Nobody expects to pass a Buffer here, 53 bits is still 28 million years after 1970, we'll be fine.\n        case 'timestamp':\n          serializer.serializeInt(buffer, 8, param);\n          break;\n\n        case 'longlong':\n          for (var j = 0; j < 8; j++) {\n            buffer[buffer.used++] = param[j];\n          }\n          break;\n\n        case 'shortstr':\n          if (typeof(param) != \"string\" || param.length > 0xFF) {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n          serializer.serializeShortString(buffer, param);\n          break;\n\n        case 'longstr':\n          serializer.serializeLongString(buffer, param);\n          break;\n\n        case 'table':\n          if (typeof(param) != \"object\") {\n            throw new Error(\"Unmatched field \" + JSON.stringify(field));\n          }\n          serializer.serializeTable(buffer, param);\n          break;\n\n        default:\n          throw new Error(\"Unknown domain value type \" + domain);\n      }\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-amqp/amqp/jspack.js":"// Copyright (c) 2008, Fair Oaks Labs, Inc.\n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without modification, are\n// permitted provided that the following conditions are met:\n// \n//     * Redistributions of source code must retain the above copyright notice, this list\n//       of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright notice, this\n//       list of conditions and the following disclaimer in the documentation and/or other\n//       materials provided with the distribution.\n//     * Neither the name of Fair Oaks Labs, Inc. nor the names of its contributors may be\n//       used to endorse or promote products derived from this software without specific\n//       prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL\n// THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n// THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// Modified from original JSPack <cbond@positrace.com>\nexports.jspack = function (bigEndian) {\n  this.bigEndian = bigEndian;\n}\n\nexports.jspack.prototype._DeArray = function (a, p, l) {\n  return [a.slice(p, p + l)];\n};\n\nexports.jspack.prototype._EnArray = function (a, p, l, v) {\n  for (var i = 0; i < l; ++i) {\n    a[p + i] = v[i] ? v[i] : 0;\n  }\n};\n\nexports.jspack.prototype._DeChar = function (a, p) {\n  return String.fromCharCode(a[p]);\n};\n\nexports.jspack.prototype._EnChar = function (a, p, v) {\n  a[p] = v.charCodeAt(0);\n};\n\nexports.jspack.prototype._DeInt = function (a, p) {\n  var lsb = bigEndian ? format.len - 1 : 0;\n  var nsb = bigEndian ? -1 : 1;\n  var stp = lsb + nsb * format.len,\n      rv;\n  var ret = 0;\n\n  var i = lsb;\n  var f = 1;\n  while (i != stp) {\n    rv += a[p + i] * f;\n    i += nsb;\n    f *= 256;\n  }\n\n  if (format.signed) {\n    if ((rv & Math.pow(2, format.len * 8 - 1)) != 0) {\n      rv -= Math.pow(2, format.len * 8);\n    }\n  }\n\n  return rv;\n};\n\nexports.jspack.prototype._EnInt = function (a, p, v) {\n  var lsb = bigEndian ? format.len - 1 : 0;\n  var nsb = bigEndian ? -1 : 1;\n  var stp = lsb + nsb * format.len;\n\n  v = v < format.min ? format.min : ((v > format.max) ? format.max : v);\n\n  var i = lsb;\n  while (i != stp) {\n    a[p + i] = v & 0xff;\n    i += nsb;\n    v >>= 8;\n  }\n};\n\nexports.jspack.prototype._DeString = function (a, p, l) {\n  var rv = new Array(1);\n\n  for (i = 0; i < l; i++) {\n    rv[i] = String.fromCharCode(a[p + i]);\n  }\n\n  return rv.join('');\n};\n\nexports.jspack.prototype._EnString = function (a, p, l, v) {\n  for (var t, i = 0; i < l; ++i) {\n    t = v.charCodeAt(i);\n    if (!t) t = 0;\n\n    a[p + i] = t;\n  }\n};\n\nexports.jspack.prototype._De754 = function (a, p) {\n  var s, e, m, i, d, bits, bit, len, bias, max;\n\n  bit = format.bit;\n  len = format.len * 8 - format.bit - 1;\n  max = (1 << len) - 1;\n  bias = max >> 1;\n\n  i = bigEndian ? 0 : format.len - 1;\n  d = bigEndian ? 1 : -1;;\n  s = a[p + i];\n  i = i + d;\n\n  bits = -7;\n\n  e = s & ((1 << -bits) - 1);\n  s >>= -bits;\n\n  for (bits += len; bits > 0; bits -= 8) {\n    e = e * 256 + a[p + i];\n    i += d;\n  }\n\n  m = e & ((1 << -bits) - 1);\n  e >>= -bits;\n\n  for (bits += bit; bits > 0; bits -= 8) {\n    m = m * 256 + a[p + i];\n    i += d;\n  }\n\n  switch (e) {\n  case 0:\n    // Zero, or denormalized number\n    e = 1 - bias;\n    break;\n\n  case max:\n    // NaN, or +/-Infinity\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n\n  default:\n    // Normalized number\n    m = m + Math.pow(2, bit);\n    e = e - bias;\n    break;\n  }\n\n  return (s ? -1 : 1) * m * Math.pow(2, e - bit);\n};\n\nexports.jspack.prototype._En754 = function (a, p, v) {\n  var s, e, m, i, d, c, bit, len, bias, max;\n\n  bit = format.bit;\n  len = format.len * 8 - format.bit - 1;\n  max = (1 << len) - 1;\n  bias = max >> 1;\n\n  s = v < 0 ? 1 : 0;\n  v = Math.abs(v);\n\n  if (isNaN(v) || (v == Infinity)) {\n    m = isNaN(v) ? 1 : 0;\n    e = max;\n  } else {\n    e = Math.floor(Math.log(v) / Math.LN2); // Calculate log2 of the value\n    c = Math.pow(2, -e);\n    if (v * c < 1) {\n      e--;\n      c = c * 2;\n    }\n\n    // Round by adding 1/2 the significand's LSD\n    if (e + bias >= 1) {\n      v += format.rt / c; // Normalized: bit significand digits\n    } else {\n      v += format.rt * Math.pow(2, 1 - bias); // Denormalized:  <= bit significand digits\n    }\n    if (v * c >= 2) {\n      e++;\n      c = c / 2; // Rounding can increment the exponent\n    }\n\n    if (e + bias >= max) { // overflow\n      m = 0;\n      e = max;\n    } else if (e + bias >= 1) { // normalized\n      m = (v * c - 1) * Math.pow(2, bit); // do not reorder this expression\n      e = e + bias;\n    } else {\n      // Denormalized - also catches the '0' case, somewhat by chance\n      m = v * Math.pow(2, bias - 1) * Math.pow(2, bit);\n      e = 0;\n    }\n  }\n\n  i = bigEndian ? format.len - 1 : 0;\n  d = bigEndian ? -1 : 1;;\n\n  while (bit >= 8) {\n    a[p + i] = m & 0xff;\n    i += d;\n    m /= 256;\n    bit -= 8;\n  }\n\n  e = (e << bit) | m;\n  for (len += bit; len > 0; len -= 8) {\n    a[p + i] = e & 0xff;\n    i += d;\n    e /= 256;\n  }\n\n  a[p + i - d] |= s * 128;\n};\n\n// Unpack a series of n formatements of size s from array a at offset p with fxn\nexports.jspack.prototype._UnpackSeries = function (n, s, a, p) {\n  var fxn = format.de;\n\n  var ret = [];\n  for (var i = 0; i < n; i++) {\n    ret.push(fxn(a, p + i * s));\n  }\n\n  return ret;\n};\n\n// Pack a series of n formatements of size s from array v at offset i to array a at offset p with fxn\nexports.jspack.prototype._PackSeries = function (n, s, a, p, v, i) {\n  var fxn = format.en;\n\n  for (o = 0; o < n; o++) {\n    fxn(a, p + o * s, v[i + o]);\n  }\n};\n\n// Unpack the octet array a, beginning at offset p, according to the fmt string\nexports.jspack.prototype.Unpack = function (fmt, a, p) {\n  bigEndian = fmt.charAt(0) != '<';\n\n  if (p == undefined || p == null) p = 0;\n\n  var re = new RegExp(this._sPattern, 'g');\n\n  var ret = [];\n\n  for (var m; m = re.exec(fmt); /* */ ) {\n    var n;\n    if (m[1] == undefined || m[1] == '') n = 1;\n    else n = parseInt(m[1]);\n\n    var s = this._lenLut[m[2]];\n\n    if ((p + n * s) > a.length) return undefined;\n\n    switch (m[2]) {\n    case 'A':\n    case 's':\n      rv.push(this._formatLut[m[2]].de(a, p, n));\n      break;\n    case 'c':\n    case 'b':\n    case 'B':\n    case 'h':\n    case 'H':\n    case 'i':\n    case 'I':\n    case 'l':\n    case 'L':\n    case 'f':\n    case 'd':\n      format = this._formatLut[m[2]];\n      ret.push(this._UnpackSeries(n, s, a, p));\n      break;\n    }\n\n    p += n * s;\n  }\n\n  return Array.prototype.concat.apply([], ret);\n};\n\n// Pack the supplied values into the octet array a, beginning at offset p, according to the fmt string\nexports.jspack.prototype.PackTo = function (fmt, a, p, values) {\n  bigEndian = (fmt.charAt(0) != '<');\n\n  var re = new RegExp(this._sPattern, 'g');\n\n  for (var m, i = 0; m = re.exec(fmt); /* */ ) {\n    var n;\n    if (m[1] == undefined || m[1] == '') n = 1;\n    else n = parseInt(m[1]);\n\n    var s = this._lenLut[m[2]];\n\n    if ((p + n * s) > a.length) return false;\n\n    switch (m[2]) {\n    case 'A':\n    case 's':\n      if ((i + 1) > values.length) return false;\n\n      this._formatLut[m[2]].en(a, p, n, values[i]);\n\n      i += 1;\n      break;\n\n    case 'c':\n    case 'b':\n    case 'B':\n    case 'h':\n    case 'H':\n    case 'i':\n    case 'I':\n    case 'l':\n    case 'L':\n    case 'f':\n    case 'd':\n      format = this._formatLut[m[2]];\n\n      if (i + n > values.length) return false;\n\n      this._PackSeries(n, s, a, p, values, i);\n\n      i += n;\n      break;\n\n    case 'x':\n      for (var j = 0; j < n; j++) {\n        a[p + j] = 0;\n      }\n      break;\n    }\n\n    p += n * s;\n  }\n\n  return a;\n};\n\n// Pack the supplied values into a new octet array, according to the fmt string\nexports.jspack.prototype.Pack = function (fmt, values) {\n  return this.PackTo(fmt, new Array(this.CalcLength(fmt)), 0, values);\n};\n\n// Determine the number of bytes represented by the format string\nexports.jspack.prototype.CalcLength = function (fmt) {\n  var re = new RegExp(this._sPattern, 'g');\n  var sz = 0;\n\n  while (match = re.exec(fmt)) {\n    var n;\n    if (match[1] == undefined || match[1] == '') n = 1;\n    else n = parseInt(match[1]);\n\n    sz += n * this._lenLut[match[2]];\n  }\n\n  return sz;\n};\n\n// Regular expression for counting digits\nexports.jspack.prototype._sPattern = '(\\\\d+)?([AxcbBhHsfdiIlL])';\n\n// Byte widths for associated formats\nexports.jspack.prototype._lenLut = {\n  'A': 1,\n  'x': 1,\n  'c': 1,\n  'b': 1,\n  'B': 1,\n  'h': 2,\n  'H': 2,\n  's': 1,\n  'f': 4,\n  'd': 8,\n  'i': 4,\n  'I': 4,\n  'l': 4,\n  'L': 4\n};\n\nexports.jspack.prototype._formatLut = {\n  'A': {\n    en: exports.jspack.prototype._EnArray,\n    de: exports.jspack.prototype._DeArray\n  },\n  's': {\n    en: exports.jspack.prototype._EnString,\n    de: exports.jspack.prototype._DeString\n  },\n  'c': {\n    en: exports.jspack.prototype._EnChar,\n    de: exports.jspack.prototype._DeChar\n  },\n  'b': {\n    en: exports.jspack.prototype._EnInt,\n    de: exports.jspack.prototype._DeInt,\n    len: 1,\n    signed: true,\n    min: -Math.pow(2, 7),\n    max: Math.pow(2, 7) - 1\n  },\n  'B': {\n    en: exports.jspack.prototype._EnInt,\n    de: exports.jspack.prototype._DeInt,\n    len: 1,\n    signed: false,\n    min: 0,\n    max: Math.pow(2, 8) - 1\n  },\n  'h': {\n    en: exports.jspack.prototype._EnInt,\n    de: exports.jspack.prototype._DeInt,\n    len: 2,\n    signed: true,\n    min: -Math.pow(2, 15),\n    max: Math.pow(2, 15) - 1\n  },\n  'H': {\n    en: exports.jspack.prototype._EnInt,\n    de: exports.jspack.prototype._DeInt,\n    len: 2,\n    signed: false,\n    min: 0,\n    max: Math.pow(2, 16) - 1\n  },\n  'i': {\n    en: exports.jspack.prototype._EnInt,\n    de: exports.jspack.prototype._DeInt,\n    len: 4,\n    signed: true,\n    min: -Math.pow(2, 31),\n    max: Math.pow(2, 31) - 1\n  },\n  'I': {\n    en: exports.jspack.prototype._EnInt,\n    de: exports.jspack.prototype._DeInt,\n    len: 4,\n    signed: false,\n    min: 0,\n    max: Math.pow(2, 32) - 1\n  },\n  'l': {\n    en: exports.jspack.prototype._EnInt,\n    de: exports.jspack.prototype._DeInt,\n    len: 4,\n    signed: true,\n    min: -Math.pow(2, 31),\n    max: Math.pow(2, 31) - 1\n  },\n  'L': {\n    en: exports.jspack.prototype._EnInt,\n    de: exports.jspack.prototype._DeInt,\n    len: 4,\n    signed: false,\n    min: 0,\n    max: Math.pow(2, 32) - 1\n  },\n  'f': {\n    en: exports.jspack.prototype._En754,\n    de: exports.jspack.prototype._De754,\n    len: 4,\n    bit: 23,\n    rt: Math.pow(2, -24) - Math.pow(2, -77)\n  },\n  'd': {\n    en: exports.jspack.prototype._En754,\n    de: exports.jspack.prototype._De754,\n    len: 8,\n    bit: 52,\n    rt: 0\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-amqp/amqp/lib/definitions.js":"'use strict';\n\nvar protocol = require('./amqp-definitions-0-9-1');\n\n// a look up table for methods recieved\n// indexed on class id, method id\nvar methodTable = {};\n\n// methods keyed on their name\nvar methods = {};\n\n// classes keyed on their index\nvar classes = {};\n\n(function () { // anon scope for init\n  //debug(\"initializing amqp methods...\");\n\n  for (var i = 0; i < protocol.classes.length; i++) {\n    var classInfo = protocol.classes[i];\n    classes[classInfo.index] = classInfo;\n\n    for (var j = 0; j < classInfo.methods.length; j++) {\n      var methodInfo = classInfo.methods[j];\n\n      var name = classInfo.name +\n        methodInfo.name[0].toUpperCase() +\n        methodInfo.name.slice(1);\n\n      //debug(name);\n\n      var method = {\n        name: name,\n        fields: methodInfo.fields,\n        methodIndex: methodInfo.index,\n        classIndex: classInfo.index\n      };\n\n      if (!methodTable[classInfo.index]) methodTable[classInfo.index] = {};\n      methodTable[classInfo.index][methodInfo.index] = method;\n      methods[name] = method;\n    }\n  }\n})();\n\nmodule.exports = {methods: methods, classes: classes, methodTable: methodTable};\n","/home/travis/build/npmtest/node-npmtest-amqp/amqp/lib/amqp-definitions-0-9-1.js":"exports.constants = [\n  [1, \"frameMethod\"],\n  [2, \"frameHeader\"],\n  [3, \"frameBody\"],\n  [8, \"frameHeartbeat\"],\n  [200, \"replySuccess\"],\n  [206, \"frameEnd\"],\n  [311, \"contentTooLarge\"],\n  [313, \"noConsumers\"],\n  [320, \"connectionForced\"],\n  [402, \"invalidPath\"],\n  [403, \"accessRefused\"],\n  [404, \"notFound\"],\n  [405, \"resourceLocked\"],\n  [406, \"preconditionFailed\"],\n  [501, \"frameError\"],\n  [502, \"syntaxError\"],\n  [503, \"commandInvalid\"],\n  [504, \"channelError\"],\n  [505, \"unexpectedFrame\"],\n  [506, \"resourceError\"],\n  [530, \"notAllowed\"],\n  [540, \"notImplemented\"],\n  [541, \"internalError\"],\n  [4096, \"frameMinSize\"]\n];\nexports.classes = [{\n  \"name\": \"connection\",\n  \"index\": 10,\n  \"fields\": [],\n  \"methods\": [{\n    \"name\": \"start\",\n    \"index\": 10,\n    \"fields\": [{\n      \"name\": \"versionMajor\",\n      \"domain\": \"octet\"\n    }, {\n      \"name\": \"versionMinor\",\n      \"domain\": \"octet\"\n    }, {\n      \"name\": \"serverProperties\",\n      \"domain\": \"table\"\n    }, {\n      \"name\": \"mechanisms\",\n      \"domain\": \"longstr\"\n    }, {\n      \"name\": \"locales\",\n      \"domain\": \"longstr\"\n    }]\n  }, {\n    \"name\": \"startOk\",\n    \"index\": 11,\n    \"fields\": [{\n      \"name\": \"clientProperties\",\n      \"domain\": \"table\"\n    }, {\n      \"name\": \"mechanism\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"response\",\n      \"domain\": \"longstr\"\n    }, {\n      \"name\": \"locale\",\n      \"domain\": \"shortstr\"\n    }]\n  }, {\n    \"name\": \"secure\",\n    \"index\": 20,\n    \"fields\": [{\n      \"name\": \"challenge\",\n      \"domain\": \"longstr\"\n    }]\n  }, {\n    \"name\": \"secureOk\",\n    \"index\": 21,\n    \"fields\": [{\n      \"name\": \"response\",\n      \"domain\": \"longstr\"\n    }]\n  }, {\n    \"name\": \"tune\",\n    \"index\": 30,\n    \"fields\": [{\n      \"name\": \"channelMax\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"frameMax\",\n      \"domain\": \"long\"\n    }, {\n      \"name\": \"heartbeat\",\n      \"domain\": \"short\"\n    }]\n  }, {\n    \"name\": \"tuneOk\",\n    \"index\": 31,\n    \"fields\": [{\n      \"name\": \"channelMax\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"frameMax\",\n      \"domain\": \"long\"\n    }, {\n      \"name\": \"heartbeat\",\n      \"domain\": \"short\"\n    }]\n  }, {\n    \"name\": \"open\",\n    \"index\": 40,\n    \"fields\": [{\n      \"name\": \"virtualHost\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"reserved1\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"reserved2\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"openOk\",\n    \"index\": 41,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"shortstr\"\n    }]\n  }, {\n    \"name\": \"close\",\n    \"index\": 50,\n    \"fields\": [{\n      \"name\": \"replyCode\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"replyText\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"classId\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"methodId\",\n      \"domain\": \"short\"\n    }]\n  }, {\n    \"name\": \"closeOk\",\n    \"index\": 51,\n    \"fields\": []\n  }, {\n    \"name\": \"blocked\",\n    \"index\": 60,\n    \"fields\": [{\n      \"name\": \"reason\",\n      \"domain\": \"shortstr\"\n    }]\n  }, {\n    \"name\": \"unblocked\",\n    \"index\": 61,\n    \"fields\": []\n  }]\n}, {\n  \"name\": \"channel\",\n  \"index\": 20,\n  \"fields\": [],\n  \"methods\": [{\n    \"name\": \"open\",\n    \"index\": 10,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"shortstr\"\n    }]\n  }, {\n    \"name\": \"openOk\",\n    \"index\": 11,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"longstr\"\n    }]\n  }, {\n    \"name\": \"flow\",\n    \"index\": 20,\n    \"fields\": [{\n      \"name\": \"active\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"flowOk\",\n    \"index\": 21,\n    \"fields\": [{\n      \"name\": \"active\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"close\",\n    \"index\": 40,\n    \"fields\": [{\n      \"name\": \"replyCode\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"replyText\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"classId\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"methodId\",\n      \"domain\": \"short\"\n    }]\n  }, {\n    \"name\": \"closeOk\",\n    \"index\": 41,\n    \"fields\": []\n  }]\n}, {\n  \"name\": \"exchange\",\n  \"index\": 40,\n  \"fields\": [],\n  \"methods\": [{\n    \"name\": \"declare\",\n    \"index\": 10,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"exchange\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"type\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"passive\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"durable\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"autoDelete\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"reserved2\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"reserved3\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"noWait\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"arguments\",\n      \"domain\": \"table\"\n    }]\n  }, {\n    \"name\": \"declareOk\",\n    \"index\": 11,\n    \"fields\": []\n  }, {\n    \"name\": \"delete\",\n    \"index\": 20,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"exchange\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"ifUnused\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"noWait\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"deleteOk\",\n    \"index\": 21,\n    \"fields\": []\n  }, {\n    \"name\": \"bind\",\n    \"index\": 30,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"destination\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"source\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"routingKey\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"noWait\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"arguments\",\n      \"domain\": \"table\"\n    }]\n  }, {\n    \"name\": \"bindOk\",\n    \"index\": 31,\n    \"fields\": []\n  }, {\n    \"name\": \"unbind\",\n    \"index\": 40,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"destination\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"source\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"routingKey\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"noWait\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"arguments\",\n      \"domain\": \"table\"\n    }]\n  }, {\n    \"name\": \"unbindOk\",\n    \"index\": 51,\n    \"fields\": []\n  }]\n}, {\n  \"name\": \"queue\",\n  \"index\": 50,\n  \"fields\": [],\n  \"methods\": [{\n    \"name\": \"declare\",\n    \"index\": 10,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"queue\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"passive\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"durable\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"exclusive\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"autoDelete\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"noWait\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"arguments\",\n      \"domain\": \"table\"\n    }]\n  }, {\n    \"name\": \"declareOk\",\n    \"index\": 11,\n    \"fields\": [{\n      \"name\": \"queue\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"messageCount\",\n      \"domain\": \"long\"\n    }, {\n      \"name\": \"consumerCount\",\n      \"domain\": \"long\"\n    }]\n  }, {\n    \"name\": \"bind\",\n    \"index\": 20,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"queue\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"exchange\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"routingKey\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"noWait\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"arguments\",\n      \"domain\": \"table\"\n    }]\n  }, {\n    \"name\": \"bindOk\",\n    \"index\": 21,\n    \"fields\": []\n  }, {\n    \"name\": \"unbind\",\n    \"index\": 50,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"queue\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"exchange\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"routingKey\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"arguments\",\n      \"domain\": \"table\"\n    }]\n  }, {\n    \"name\": \"unbindOk\",\n    \"index\": 51,\n    \"fields\": []\n  }, {\n    \"name\": \"purge\",\n    \"index\": 30,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"queue\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"noWait\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"purgeOk\",\n    \"index\": 31,\n    \"fields\": [{\n      \"name\": \"messageCount\",\n      \"domain\": \"long\"\n    }]\n  }, {\n    \"name\": \"delete\",\n    \"index\": 40,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"queue\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"ifUnused\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"ifEmpty\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"noWait\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"deleteOk\",\n    \"index\": 41,\n    \"fields\": [{\n      \"name\": \"messageCount\",\n      \"domain\": \"long\"\n    }]\n  }]\n}, {\n  \"name\": \"basic\",\n  \"index\": 60,\n  \"fields\": [{\n    \"name\": \"contentType\",\n    \"domain\": \"shortstr\"\n  }, {\n    \"name\": \"contentEncoding\",\n    \"domain\": \"shortstr\"\n  }, {\n    \"name\": \"headers\",\n    \"domain\": \"table\"\n  }, {\n    \"name\": \"deliveryMode\",\n    \"domain\": \"octet\"\n  }, {\n    \"name\": \"priority\",\n    \"domain\": \"octet\"\n  }, {\n    \"name\": \"correlationId\",\n    \"domain\": \"shortstr\"\n  }, {\n    \"name\": \"replyTo\",\n    \"domain\": \"shortstr\"\n  }, {\n    \"name\": \"expiration\",\n    \"domain\": \"shortstr\"\n  }, {\n    \"name\": \"messageId\",\n    \"domain\": \"shortstr\"\n  }, {\n    \"name\": \"timestamp\",\n    \"domain\": \"timestamp\"\n  }, {\n    \"name\": \"type\",\n    \"domain\": \"shortstr\"\n  }, {\n    \"name\": \"userId\",\n    \"domain\": \"shortstr\"\n  }, {\n    \"name\": \"appId\",\n    \"domain\": \"shortstr\"\n  }, {\n    \"name\": \"reserved\",\n    \"domain\": \"shortstr\"\n  }],\n  \"methods\": [{\n    \"name\": \"qos\",\n    \"index\": 10,\n    \"fields\": [{\n      \"name\": \"prefetchSize\",\n      \"domain\": \"long\"\n    }, {\n      \"name\": \"prefetchCount\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"global\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"qosOk\",\n    \"index\": 11,\n    \"fields\": []\n  }, {\n    \"name\": \"consume\",\n    \"index\": 20,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"queue\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"consumerTag\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"noLocal\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"noAck\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"exclusive\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"noWait\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"arguments\",\n      \"domain\": \"table\"\n    }]\n  }, {\n    \"name\": \"consumeOk\",\n    \"index\": 21,\n    \"fields\": [{\n      \"name\": \"consumerTag\",\n      \"domain\": \"shortstr\"\n    }]\n  }, {\n    \"name\": \"cancel\",\n    \"index\": 30,\n    \"fields\": [{\n      \"name\": \"consumerTag\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"noWait\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"cancelOk\",\n    \"index\": 31,\n    \"fields\": [{\n      \"name\": \"consumerTag\",\n      \"domain\": \"shortstr\"\n    }]\n  }, {\n    \"name\": \"publish\",\n    \"index\": 40,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"exchange\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"routingKey\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"mandatory\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"immediate\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"return\",\n    \"index\": 50,\n    \"fields\": [{\n      \"name\": \"replyCode\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"replyText\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"exchange\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"routingKey\",\n      \"domain\": \"shortstr\"\n    }]\n  }, {\n    \"name\": \"deliver\",\n    \"index\": 60,\n    \"fields\": [{\n      \"name\": \"consumerTag\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"deliveryTag\",\n      \"domain\": \"longlong\"\n    }, {\n      \"name\": \"redelivered\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"exchange\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"routingKey\",\n      \"domain\": \"shortstr\"\n    }]\n  }, {\n    \"name\": \"get\",\n    \"index\": 70,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"short\"\n    }, {\n      \"name\": \"queue\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"noAck\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"getOk\",\n    \"index\": 71,\n    \"fields\": [{\n      \"name\": \"deliveryTag\",\n      \"domain\": \"longlong\"\n    }, {\n      \"name\": \"redelivered\",\n      \"domain\": \"bit\"\n    }, {\n      \"name\": \"exchange\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"routingKey\",\n      \"domain\": \"shortstr\"\n    }, {\n      \"name\": \"messageCount\",\n      \"domain\": \"long\"\n    }]\n  }, {\n    \"name\": \"getEmpty\",\n    \"index\": 72,\n    \"fields\": [{\n      \"name\": \"reserved1\",\n      \"domain\": \"shortstr\"\n    }]\n  }, {\n    \"name\": \"ack\",\n    \"index\": 80,\n    \"fields\": [{\n      \"name\": \"deliveryTag\",\n      \"domain\": \"longlong\"\n    }, {\n      \"name\": \"multiple\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"reject\",\n    \"index\": 90,\n    \"fields\": [{\n      \"name\": \"deliveryTag\",\n      \"domain\": \"longlong\"\n    }, {\n      \"name\": \"requeue\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"recoverAsync\",\n    \"index\": 100,\n    \"fields\": [{\n      \"name\": \"requeue\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"recover\",\n    \"index\": 110,\n    \"fields\": [{\n      \"name\": \"requeue\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"recoverOk\",\n    \"index\": 111,\n    \"fields\": []\n  }]\n}, {\n  \"name\": \"tx\",\n  \"index\": 90,\n  \"fields\": [],\n  \"methods\": [{\n    \"name\": \"select\",\n    \"index\": 10,\n    \"fields\": []\n  }, {\n    \"name\": \"selectOk\",\n    \"index\": 11,\n    \"fields\": []\n  }, {\n    \"name\": \"commit\",\n    \"index\": 20,\n    \"fields\": []\n  }, {\n    \"name\": \"commitOk\",\n    \"index\": 21,\n    \"fields\": []\n  }, {\n    \"name\": \"rollback\",\n    \"index\": 30,\n    \"fields\": []\n  }, {\n    \"name\": \"rollbackOk\",\n    \"index\": 31,\n    \"fields\": []\n  }]\n}, {\n  \"name\": \"confirm\",\n  \"index\": 85,\n  \"fields\": [],\n  \"methods\": [{\n    \"name\": \"select\",\n    \"index\": 10,\n    \"fields\": [{\n      \"name\": \"noWait\",\n      \"domain\": \"bit\"\n    }]\n  }, {\n    \"name\": \"selectOk\",\n    \"index\": 11,\n    \"fields\": []\n  }]\n}];\n","/home/travis/build/npmtest/node-npmtest-amqp/amqp/lib/exchange.js":"'use strict';\nvar events = require('events');\nvar util = require('util');\nvar net = require('net');\nvar tls = require('tls');\nvar fs = require('fs');\nvar _ = require('lodash');\nvar methods = require('./definitions').methods;\nvar Channel = require('./channel');\nvar debug = require('./debug');\n\nvar Exchange = module.exports = function Exchange (connection, channel, name, options, openCallback) {\n  Channel.call(this, connection, channel);\n  this.name = name;\n  this.binds = 0; // keep track of queues bound\n  this.exchangeBinds = 0; // keep track of exchanges bound\n  this.sourceExchanges = {};\n  this.options = _.defaults(options || {}, {autoDelete: true});\n  this._openCallback = openCallback;\n\n  this._sequence = null;\n  this._unAcked  = {};\n  this._addedExchangeErrorHandler = false;\n};\nutil.inherits(Exchange, Channel);\n\n// creates an error handler scoped to the given `exchange`\nfunction createExchangeErrorHandlerFor (exchange) {\n  return function (err) {\n    if (!exchange.options.confirm) return;\n\n    // should requeue instead?\n    // https://www.rabbitmq.com/reliability.html#producer\n    debug && debug('Exchange error handler triggered, erroring and wiping all unacked publishes');\n    for (var id in exchange._unAcked) {\n      var task = exchange._unAcked[id];\n      task.emit('ack error', err);\n      delete exchange._unAcked[id];\n    }\n  };\n}\n\nExchange.prototype._onMethod = function (channel, method, args) {\n  this.emit(method.name, args);\n\n  if (this._handleTaskReply.apply(this, arguments))\n    return true;\n\n  var cb;\n\n  switch (method) {\n    case methods.channelOpenOk:\n      this._sequence = null;\n\n      if (!this._addedExchangeErrorHandler) {\n        var errorHandler = createExchangeErrorHandlerFor(this);\n        this.connection.on('error', errorHandler);\n        this.on('error', errorHandler);\n        this._addedExchangeErrorHandler = true;\n      }\n\n      // Pre-baked exchanges don't need to be declared\n      if (/^$|(amq\\.)/.test(this.name)) {\n        //If confirm mode is specified we have to set it no matter the exchange.\n        if (this.options.confirm) {\n          this._confirmSelect(channel);\n          return;\n        }\n\n        this.state = 'open';\n        // - issue #33 fix\n        if (this._openCallback) {\n         this._openCallback(this);\n         this._openCallback = null;\n        }\n        // --\n        this.emit('open');\n\n      // For if we want to delete a exchange,\n      // we dont care if all of the options match.\n      } else if (this.options.noDeclare) {\n        if (this.options.confirm) {\n          this._confirmSelect(channel);\n          this.state = 'open';\n\n          if (this._openCallback) {\n           this._openCallback(this);\n           this._openCallback = null;\n          }\n\n          this.emit('open');\n        }\n      } else {\n        this.connection._sendMethod(channel, methods.exchangeDeclare,\n            { reserved1:  0\n            , reserved2:  false\n            , reserved3:  false\n            , exchange:   this.name\n            , type:       this.options.type || 'topic'\n            , passive:    !!this.options.passive\n            , durable:    !!this.options.durable\n            , autoDelete: !!this.options.autoDelete\n            , internal:   !!this.options.internal\n            , noWait:     false\n            , \"arguments\":this.options.arguments || {}\n            });\n        this.state = 'declaring';\n      }\n      break;\n\n    case methods.exchangeDeclareOk:\n      if (this.options.confirm) {\n        this._confirmSelect(channel);\n      } else {\n\n        this.state = 'open';\n        this.emit('open');\n        if (this._openCallback) {\n          this._openCallback(this);\n          this._openCallback = null;\n        }\n      }\n      break;\n\n    case methods.confirmSelectOk:\n      this._sequence = 1;\n\n      this.state = 'open';\n      this.emit('open');\n      if (this._openCallback) {\n        this._openCallback(this);\n        this._openCallback = null;\n      }\n      break;\n\n    case methods.channelClose:\n      this.state = \"closed\";\n      this.closeOK();\n      this.connection.exchangeClosed(this.name);\n      var e = new Error(args.replyText);\n      e.code = args.replyCode;\n      this.emit('error', e);\n      this.emit('close');\n      break;\n\n    case methods.channelCloseOk:\n      this.connection.exchangeClosed(this.name);\n      this.emit('close');\n      break;\n\n\n    case methods.basicAck:\n      this.emit('basic-ack', args);\n      var sequenceNumber = args.deliveryTag.readUInt32BE(4), tag;\n      debug && debug(\"basic-ack, sequence: \", sequenceNumber);\n\n      if (sequenceNumber === 0 && args.multiple === true) {\n        // we must ack everything\n        for (tag in this._unAcked) {\n          this._unAcked[tag].emit('ack');\n          delete this._unAcked[tag];\n        }\n      } else if (sequenceNumber !== 0 && args.multiple === true) {\n        // we must ack everything before the delivery tag\n        for (tag in this._unAcked) {\n          if (tag <= sequenceNumber) {\n            this._unAcked[tag].emit('ack');\n            delete this._unAcked[tag];\n          }\n        }\n      } else if (this._unAcked[sequenceNumber] && args.multiple === false) {\n        // simple single ack\n        this._unAcked[sequenceNumber].emit('ack');\n        delete this._unAcked[sequenceNumber];\n      }\n      break;\n\n    case methods.basicReturn:\n      this.emit('basic-return', args);\n      break;\n\n    case methods.exchangeBindOk:\n      if (this._bindCallback) {\n        // setting this._bindCallback to null before calling the callback allows for a subsequent bind within the callback\n        cb = this._bindCallback;\n        this._bindCallback = null;\n        cb(this);\n      }\n      break;\n\n    case methods.exchangeUnbindOk:\n      if (this._unbindCallback) {\n        cb = this._unbindCallback;\n        this._unbindCallback = null;\n        cb(this);\n      }\n      break;\n\n    default:\n      throw new Error(\"Uncaught method '\" + method.name + \"' with args \" +\n        JSON.stringify(args));\n  }\n\n  this._tasksFlush();\n};\n\n// exchange.publish('routing.key', 'body');\n//\n// the third argument can specify additional options\n// - mandatory (boolean, default false)\n// - immediate (boolean, default false)\n// - contentType (default 'application/octet-stream')\n// - contentEncoding\n// - headers\n// - deliveryMode\n// - priority (0-9)\n// - correlationId\n// - replyTo\n// - expiration\n// - messageId\n// - timestamp\n// - userId\n// - appId\n// - clusterId\n//\n// the callback is optional and is only used when confirm is turned on for the exchange\n\nExchange.prototype.publish = function (routingKey, data, options, callback) {\n  var self = this;\n  callback = callback || function() {};\n\n  if (this.connection._blocked) {\n    return callback(true, new Error('Connection is blocked, server reason: ' + this.connection._blockedReason));\n  }\n\n  if (this.state !== 'open') {\n    this._sequence = null;\n    return callback(true, new Error('Can not publish: exchange is not open'));\n  }\n\n  if (this.options.confirm && !this._readyToPublishWithConfirms()) {\n    return callback(true, new Error('Not yet ready to publish with confirms'));\n  }\n\n  options = _.assignIn({}, options || {});\n  options.routingKey = routingKey;\n  options.exchange   = self.name;\n  options.mandatory  = options.mandatory ? true : false;\n  options.immediate  = options.immediate ? true : false;\n  options.reserved1  = 0;\n\n  var task = this._taskPush(null, function () {\n    self.connection._sendMethod(self.channel, methods.basicPublish, options);\n    // This interface is probably not appropriate for streaming large files.\n    // (Of course it's arguable about whether AMQP is the appropriate\n    // transport for large files.) The content header wants to know the size\n    // of the data before sending it - so there's no point in trying to have a\n    // general streaming interface - streaming messages of unknown size simply\n    // isn't possible with AMQP. This is all to say, don't send big messages.\n    // If you need to stream something large, chunk it yourself.\n    self.connection._sendBody(self.channel, data, options);\n  });\n\n  if (self.options.confirm) self._awaitConfirm(task, callback);\n  return task;\n};\n\n// registers tasks for confirms\nExchange.prototype._awaitConfirm = function _awaitConfirm (task, callback) {\n  if (!this._addedExchangeErrorHandler) {\n    // if connection fails, we want to ack error all unacked publishes.\n    this.connection.on('error', createExchangeErrorHandlerFor(this));\n    this.on('error', createExchangeErrorHandlerFor(this));\n    this._addedExchangeErrorHandler = true;\n  }\n\n  debug && debug('awaiting confirmation for ' + this._sequence);\n  task.sequence = this._sequence;\n  this._unAcked[this._sequence] = task;\n  this._sequence++;\n\n  if ('function' != typeof callback) return;\n\n  task.once('ack error', function (err) {\n    task.removeAllListeners();\n    callback(true, err);\n  });\n\n  task.once('ack', function () {\n    task.removeAllListeners();\n    callback(false);\n  });\n};\n\n// do any necessary cleanups eg. after queue destruction\nExchange.prototype.cleanup = function() {\n  if (this.binds === 0) { // don't keep reference open if unused\n    this.connection.exchangeClosed(this.name);\n  }\n};\n\nExchange.prototype.destroy = function (ifUnused) {\n  var self = this;\n  return this._taskPush(methods.exchangeDeleteOk, function () {\n    self.connection.exchangeClosed(self.name);\n    self.connection._sendMethod(self.channel, methods.exchangeDelete,\n        { reserved1: 0\n        , exchange: self.name\n        , ifUnused: ifUnused ? true : false\n        , noWait: false\n        });\n  });\n};\n\n// E2E Unbind\n// support RabbitMQ's exchange-to-exchange binding extension\n// http://www.rabbitmq.com/e2e.html\nExchange.prototype.unbind = function (/* exchange, routingKey [, bindCallback] */) {\n  var self = this;\n\n  // Both arguments are required. The binding to the destination\n  // exchange/routingKey will be unbound.\n\n  var exchange    = arguments[0]\n    , routingKey  = arguments[1]\n    , callback    = arguments[2]\n  ;\n\n  if (callback) this._unbindCallback = callback;\n\n  return this._taskPush(methods.exchangeUnbindOk, function () {\n    var source = exchange instanceof Exchange ? exchange.name : exchange;\n    var destination = self.name;\n\n    if (source in self.connection.exchanges) {\n      delete self.sourceExchanges[source];\n      self.connection.exchanges[source].exchangeBinds--;\n    }\n\n    self.connection._sendMethod(self.channel, methods.exchangeUnbind,\n        { reserved1: 0\n        , destination: destination\n        , source: source\n        , routingKey: routingKey\n        , noWait: false\n        , \"arguments\": {}\n        });\n  });\n};\n\n// E2E Bind\n// support RabbitMQ's exchange-to-exchange binding extension\n// http://www.rabbitmq.com/e2e.html\nExchange.prototype.bind = function (/* exchange, routingKey [, bindCallback] */) {\n  var self = this;\n\n  // Two arguments are required. The binding to the destination\n  // exchange/routingKey will be established.\n\n  var exchange    = arguments[0]\n    , routingKey  = arguments[1]\n    , callback    = arguments[2]\n  ;\n\n  if (callback) this._bindCallback = callback;\n\n  var source = exchange instanceof Exchange ? exchange.name : exchange;\n  var destination = self.name;\n\n  if(source in self.connection.exchanges) {\n    self.sourceExchanges[source] = self.connection.exchanges[source];\n    self.connection.exchanges[source].exchangeBinds++;\n  }\n\n  self.connection._sendMethod(self.channel, methods.exchangeBind,\n      { reserved1: 0\n      , destination: destination\n      , source: source\n      , routingKey: routingKey\n      , noWait: false\n      , \"arguments\": {}\n      });\n\n};\n\n// E2E Bind\n// support RabbitMQ's exchange-to-exchange binding extension\n// http://www.rabbitmq.com/e2e.html\nExchange.prototype.bind_headers = function (/* exchange, routing [, bindCallback] */) {\n  var self = this;\n\n  // Two arguments are required. The binding to the destination\n  // exchange/routingKey will be established.\n\n  var exchange = arguments[0]\n    , routing  = arguments[1]\n    , callback = arguments[2]\n  ;\n\n  if (callback) this._bindCallback = callback;\n\n  var source = exchange instanceof Exchange ? exchange.name : exchange;\n  var destination = self.name;\n\n  if (source in self.connection.exchanges) {\n    self.sourceExchanges[source] = self.connection.exchanges[source];\n    self.connection.exchanges[source].exchangeBinds++;\n  }\n\n  self.connection._sendMethod(self.channel, methods.exchangeBind,\n    { reserved1: 0\n        , destination: destination\n        , source: source\n        , routingKey: ''\n        , noWait: false\n        , \"arguments\": routing\n    });\n};\n\nExchange.prototype._confirmSelect = function(channel) {\n  this.connection._sendMethod(channel, methods.confirmSelect, { noWait: false });\n};\n\nExchange.prototype._readyToPublishWithConfirms = function() {\n  return this._sequence != null;\n};\n","/home/travis/build/npmtest/node-npmtest-amqp/amqp/lib/channel.js":"'use strict';\nvar events = require('events');\nvar util = require('util');\nvar fs = require('fs');\nvar Promise = require('./promise').Promise;\nvar definitions = require('./definitions');\nvar methods = definitions.methods;\n\n// This class is not exposed to the user. Queue and Exchange are subclasses\n// of Channel. This just provides a task queue.\nvar Channel = module.exports = function Channel (connection, channel) {\n  events.EventEmitter.call(this);\n\n  // Unlimited listeners. Helps when e.g. publishing high-volume messages,\n  // 10 is far too low.\n  this.setMaxListeners(0);\n\n  this.channel = channel;\n  this.connection = connection;\n  this._tasks = [];\n\n  this.reconnect();\n};\nutil.inherits(Channel, events.EventEmitter);\n\nChannel.prototype.closeOK = function() {\n  this.connection._sendMethod(this.channel, methods.channelCloseOk, {reserved1: \"\"});\n};\n\nChannel.prototype.reconnect = function () {\n  this.connection._sendMethod(this.channel, methods.channelOpen, {reserved1: \"\"});\n};\n\nChannel.prototype._taskPush = function (reply, cb) {\n  var promise = new Promise();\n  this._tasks.push({\n    promise: promise,\n    reply: reply,\n    sent: false,\n    cb: cb\n  });\n  this._tasksFlush();\n  return promise;\n};\n\nChannel.prototype._tasksFlush = function () {\n  if (this.state != 'open') return;\n\n  for (var i = 0; i < this._tasks.length; i++) {\n    var task = this._tasks[i];\n    if (task.sent) continue;\n    task.cb();\n    task.sent = true;\n    if (!task.reply) {\n      // if we don't expect a reply, just delete it now\n      this._tasks.splice(i, 1);\n      i = i-1;\n    }\n  }\n};\n\nChannel.prototype._handleTaskReply = function (channel, method, args) {\n  var task, i;\n\n  for (i = 0; i < this._tasks.length; i++) {\n    if (this._tasks[i].reply == method) {\n      task = this._tasks[i];\n      this._tasks.splice(i, 1);\n      task.promise.emitSuccess(args);\n      this._tasksFlush();\n      return true;\n    }\n  }\n\n  return false;\n};\n\nChannel.prototype._onChannelMethod = function(channel, method, args) {\n  switch (method) {\n    case methods.channelCloseOk:\n      delete this.connection.channels[this.channel];\n      this.state = 'closed';\n      // TODO should this be falling through?\n    default:\n      this._onMethod(channel, method, args);\n  }\n};\n\nChannel.prototype.close = function(reason) {\n  this.state = 'closing';\n  this.connection._sendMethod(this.channel, methods.channelClose,\n                              {'replyText': reason ? reason : 'Goodbye from node',\n                               'replyCode': 200,\n                               'classId': 0,\n                               'methodId': 0});\n};\n","/home/travis/build/npmtest/node-npmtest-amqp/amqp/lib/promise.js":"var events = require('events');\nvar inherits = require('util').inherits;\n\nexports.Promise = function () {\n  events.EventEmitter.call(this);\n  this._blocking = false;\n  this.hasFired = false;\n  this.hasAcked = false;\n  this._values = undefined;\n};\ninherits(exports.Promise, events.EventEmitter);\n\nexports.Promise.prototype.timeout = function(timeout) {\n  if (!timeout) {\n    return this._timeoutDuration;\n  }\n\n  this._timeoutDuration = timeout;\n\n  if (this.hasFired) return;\n  this._clearTimeout();\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._timer = null;\n    if (self.hasFired) {\n      return;\n    }\n\n    self.emitError(new Error('timeout'));\n  }, timeout);\n\n  return this;\n};\n\nexports.Promise.prototype._clearTimeout = function() {\n  if (!this._timer) return;\n\n  clearTimeout(this._timer);\n  this._timer = null;\n}\n\nexports.Promise.prototype.emitSuccess = function() {\n  if (this.hasFired) return;\n  this.hasFired = 'success';\n  this._clearTimeout();\n\n  this._values = Array.prototype.slice.call(arguments);\n  this.emit.apply(this, ['success'].concat(this._values));\n};\n\nexports.Promise.prototype.emitError = function() {\n  if (this.hasFired) return;\n  this.hasFired = 'error';\n  this._clearTimeout();\n\n  this._values = Array.prototype.slice.call(arguments);\n  this.emit.apply(this, ['error'].concat(this._values));\n\n  if (this.listeners('error').length == 0) {\n    var self = this;\n    process.nextTick(function() {\n      if (self.listeners('error').length == 0) {\n        throw (self._values[0] instanceof Error)\n          ? self._values[0]\n          : new Error('Unhandled emitError: '+JSON.stringify(self._values));\n      }\n    });\n  }\n};\n\nexports.Promise.prototype.addCallback = function (listener) {\n  if (this.hasFired === 'success') {\n    listener.apply(this, this._values);\n  }\n\n  return this.addListener(\"success\", listener);\n};\n\nexports.Promise.prototype.addErrback = function (listener) {\n  if (this.hasFired === 'error') {\n    listener.apply(this, this._values);\n  }\n\n  return this.addListener(\"error\", listener);\n};\n","/home/travis/build/npmtest/node-npmtest-amqp/amqp/lib/queue.js":"'use strict';\nvar util = require('util');\nvar fs = require('fs');\nvar StringDecoder = require('string_decoder').StringDecoder;\nvar _ = require('lodash');\nvar Channel = require('./channel');\nvar Exchange = require('./exchange');\nvar Message = require('./message');\nvar debug = require('./debug');\nvar definitions = require('./definitions');\nvar methods = definitions.methods;\nvar classes = definitions.classes;\n\nvar Queue = module.exports = function Queue (connection, channel, name, options, callback) {\n  Channel.call(this, connection, channel);\n\n  var self = this;\n  this.name = name;\n  this._bindings = {};\n  this.consumerTagListeners = {};\n  this.consumerTagOptions = {};\n\n  // route messages to subscribers based on consumerTag\n  this.on('rawMessage', function(message) {\n    if (message.consumerTag && self.consumerTagListeners[message.consumerTag]) {\n      self.consumerTagListeners[message.consumerTag](message);\n    }\n  });\n\n  this.options = { autoDelete: true, closeChannelOnUnsubscribe: false };\n  _.assignIn(this.options, options || {});\n\n  this._openCallback = callback;\n};\nutil.inherits(Queue, Channel);\n\nQueue.prototype.subscribeRaw = function (options, messageListener) {\n  var self = this;\n\n  // multiple method signatures\n  if (typeof options === \"function\") {\n    messageListener = options;\n    options = {};\n  }\n\n  var consumerTag = 'node-amqp-' + process.pid + '-' + Math.random();\n  this.consumerTagListeners[consumerTag] = messageListener;\n\n  options = options || {};\n  options['state'] = 'opening';\n  this.consumerTagOptions[consumerTag] = options;\n  if (options.prefetchCount !== undefined) {\n    self.connection._sendMethod(self.channel, methods.basicQos,\n        { reserved1: 0\n        , prefetchSize: 0\n        , prefetchCount: options.prefetchCount\n        , global: false\n        });\n  }\n\n  return this._taskPush(methods.basicConsumeOk, function () {\n    self.connection._sendMethod(self.channel, methods.basicConsume,\n        { reserved1: 0\n        , queue: self.name\n        , consumerTag: consumerTag\n        , noLocal: !!options.noLocal\n        , noAck: !!options.noAck\n        , exclusive: !!options.exclusive\n        , noWait: false\n        , \"arguments\": {}\n        });\n    self.consumerTagOptions[consumerTag]['state'] = 'open';\n  });\n};\n\nQueue.prototype.unsubscribe = function(consumerTag) {\n  var self = this;\n  return this._taskPush(methods.basicCancelOk, function () {\n    self.connection._sendMethod(self.channel, methods.basicCancel,\n                                { reserved1: 0,\n                                  consumerTag: consumerTag,\n                                  noWait: false });\n  })\n  .addCallback(function () {\n    if (self.options.closeChannelOnUnsubscribe) {\n      self.close();\n    }\n    delete self.consumerTagListeners[consumerTag];\n    delete self.consumerTagOptions[consumerTag];\n  });\n};\n\nQueue.prototype.subscribe = function (options, messageListener) {\n  var self = this;\n\n  // Optional options\n  if (typeof options === \"function\") {\n    messageListener = options;\n    options = {};\n  }\n\n  options = _.defaults(options || {}, {\n    ack: false,\n    prefetchCount: 1,\n    routingKeyInPayload: self.connection.options.routingKeyInPayload,\n    deliveryTagInPayload: self.connection.options.deliveryTagInPayload\n  });\n\n  // basic consume\n  var rawOptions = {\n      noAck: !options.ack,\n      exclusive: options.exclusive\n  };\n\n  if (options.ack) {\n    rawOptions['prefetchCount'] = options.prefetchCount;\n  }\n\n  return this.subscribeRaw(rawOptions, function (m) {\n    var contentType = m.contentType;\n    var decoder = new StringDecoder('utf8');\n\n    if (contentType == null && m.headers && m.headers.properties) {\n      contentType = m.headers.properties.content_type;\n    }\n\n    var isJSON = contentType == 'text/json' ||\n                 contentType == 'application/json';\n\n    var buffer;\n\n    if (isJSON) {\n      buffer = \"\";\n    } else {\n      buffer = new Buffer(m.size);\n      buffer.used = 0;\n    }\n\n    self._lastMessage = m;\n\n    m.addListener('data', function (d) {\n      if (isJSON) {\n        buffer += decoder.write(d);\n      } else {\n        d.copy(buffer, buffer.used);\n        buffer.used += d.length;\n      }\n    });\n\n    m.addListener('end', function () {\n      var json, deliveryInfo = {}, msgProperties = classes[60].fields, i, l;\n\n      if (isJSON) {\n        decoder.end();\n        try {\n          json = JSON.parse(buffer);\n        } catch (e) {\n          json = null;\n          deliveryInfo.parseError = e;\n          deliveryInfo.rawData = buffer;\n        }\n      } else {\n        json = { data: buffer, contentType: m.contentType };\n      }\n\n      for (i = 0, l = msgProperties.length; i<l; i++) {\n        if (m[msgProperties[i].name]) {\n          deliveryInfo[msgProperties[i].name] = m[msgProperties[i].name];\n        }\n      }\n\n      deliveryInfo.queue = m.queue ? m.queue.name : null;\n      deliveryInfo.deliveryTag = m.deliveryTag;\n      deliveryInfo.redelivered = m.redelivered;\n      deliveryInfo.exchange = m.exchange;\n      deliveryInfo.routingKey = m.routingKey;\n      deliveryInfo.consumerTag = m.consumerTag;\n\n      if (options.routingKeyInPayload) json._routingKey = m.routingKey;\n      if (options.deliveryTagInPayload) json._deliveryTag = m.deliveryTag;\n\n      var headers = {};\n      for (i in this.headers) {\n        if (this.headers.hasOwnProperty(i)) {\n          if (this.headers[i] instanceof Buffer) {\n            headers[i] = this.headers[i].toString();\n          } else {\n            headers[i] = this.headers[i];\n          }\n        }\n      }\n\n      if (messageListener) messageListener(json, headers, deliveryInfo, m);\n      self.emit('message', json, headers, deliveryInfo, m);\n    });\n  });\n};\nQueue.prototype.subscribeJSON = Queue.prototype.subscribe;\n\n/* Acknowledges the last message */\nQueue.prototype.shift = function (reject, requeue) {\n  if (this._lastMessage) {\n    if (reject) {\n      this._lastMessage.reject(requeue ? true : false);\n    } else {\n      this._lastMessage.acknowledge();\n    }\n    this._lastMessage = null;\n  }\n};\n\n\nQueue.prototype.bind = function (exchange, routingKey, callback) {\n  var self = this;\n\n  // The first argument, exchange is optional.\n  // If not supplied the connection will use the 'amq.topic'\n  // exchange.\n  if (routingKey === undefined || _.isFunction(routingKey)) {\n    callback = routingKey;\n    routingKey = exchange;\n    exchange = 'amq.topic';\n  }\n\n  if (_.isFunction(callback)) this._bindCallback = callback;\n\n  var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;\n\n  if (exchangeName in self.connection.exchanges) {\n    this.exchange = self.connection.exchanges[exchangeName];\n    this.exchange.binds++;\n  }\n\n  // Record this binding so we can restore it upon reconnect.\n  if (!this._bindings[exchangeName]) {\n    this._bindings[exchangeName] = {};\n  }\n\n  if (!this._bindings[exchangeName][routingKey]) {\n    this._bindings[exchangeName][routingKey] = 0;\n  }\n\n  this._bindings[exchangeName][routingKey]++;\n\n  self.connection._sendMethod(self.channel, methods.queueBind,\n      { reserved1: 0\n      , queue: self.name\n      , exchange: exchangeName\n      , routingKey: routingKey\n      , noWait: false\n      , \"arguments\": {}\n      });\n\n};\n\nQueue.prototype.unbind = function (exchange, routingKey) {\n  var self = this;\n\n  // The first argument, exchange is optional.\n  // If not supplied the connection will use the default 'amq.topic'\n  // exchange.\n  if (routingKey === undefined) {\n    routingKey = exchange;\n    exchange = 'amq.topic';\n  }\n\n  var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;\n\n  // Decrement binding count.\n  this._bindings[exchangeName][routingKey]--;\n  if (!this._bindings[exchangeName][routingKey]) {\n    delete this._bindings[exchangeName][routingKey];\n  }\n\n  // If there are no more bindings to this exchange, delete the key for the exchange.\n  if (!_.keys(this._bindings[exchangeName]).length){\n    delete this._bindings[exchangeName];\n  }\n\n  return this._taskPush(methods.queueUnbindOk, function () {\n    self.connection._sendMethod(self.channel, methods.queueUnbind,\n        { reserved1: 0\n        , queue: self.name\n        , exchange: exchangeName\n        , routingKey: routingKey\n        , noWait: false\n        , \"arguments\": {}\n        });\n  });\n};\n\nQueue.prototype.bind_headers = function (/* [exchange,] matchingPairs */) {\n  var self = this;\n\n  // The first argument, exchange is optional.\n  // If not supplied the connection will use the default 'amq.headers'\n  // exchange.\n\n  var exchange, matchingPairs;\n\n  if (arguments.length == 2) {\n    exchange = arguments[0];\n    matchingPairs = arguments[1];\n  } else {\n    exchange = 'amq.headers';\n    matchingPairs = arguments[0];\n  }\n\n\n  return this._taskPush(methods.queueBindOk, function () {\n    var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;\n    self.connection._sendMethod(self.channel, methods.queueBind,\n        { reserved1: 0\n        , queue: self.name\n        , exchange: exchangeName\n        , routingKey: ''\n        , noWait: false\n        , \"arguments\": matchingPairs\n        });\n  });\n};\n\nQueue.prototype.unbind_headers = function (/* [exchange,] matchingPairs */) {\n  var self = this;\n\n  // The first argument, exchange is optional.\n  // If not supplied the connection will use the default 'amq.topic'\n  // exchange.\n\n  var exchange, matchingPairs;\n\n  if (arguments.length === 2) {\n    exchange = arguments[0];\n    matchingPairs = arguments[1];\n  } else {\n    exchange = 'amq.headers';\n    matchingPairs = arguments[0];\n  }\n\n  return this._taskPush(methods.queueUnbindOk, function () {\n    var exchangeName = exchange instanceof Exchange ? exchange.name : exchange;\n    self.connection._sendMethod(self.channel, methods.queueUnbind,\n        { reserved1: 0\n        , queue: self.name\n        , exchange: exchangeName\n        , routingKey: ''\n        , noWait: false\n        , \"arguments\": matchingPairs\n        });\n  });\n};\n\nQueue.prototype.destroy = function (options) {\n  var self = this;\n\n  options = options || {};\n  return this._taskPush(methods.queueDeleteOk, function () {\n    self.connection.queueClosed(self.name);\n    if ('exchange' in self) {\n      self.exchange.binds--;\n    }\n    self.connection._sendMethod(self.channel, methods.queueDelete,\n        { reserved1: 0\n        , queue: self.name\n        , ifUnused: options.ifUnused ? true : false\n        , ifEmpty: options.ifEmpty ? true : false\n        , noWait: false\n        , \"arguments\": {}\n    });\n  });\n};\n\nQueue.prototype.purge = function() {\n  var self = this;\n  return this._taskPush(methods.queuePurgeOk, function () {\n    self.connection._sendMethod(self.channel, methods.queuePurge,\n                                 { reserved1 : 0,\n                                 queue: self.name,\n                                 noWait: false});\n  });\n};\n\n\nQueue.prototype._onMethod = function (channel, method, args) {\n  var self = this;\n  this.emit(method.name, args);\n  if (this._handleTaskReply.apply(this, arguments)) return;\n\n  switch (method) {\n    case methods.channelOpenOk:\n      if (this.options.noDeclare) {\n        this.state = 'open';\n\n        if (this._openCallback) {\n         this._openCallback(this);\n         this._openCallback = null;\n        }\n\n        this.emit('open');\n      } else {\n        if (this.name.indexOf('amq.') == 0) {\n          this.name = '';\n        }\n        this.connection._sendMethod(channel, methods.queueDeclare,\n            { reserved1: 0\n            , queue: this.name\n            , passive: !!this.options.passive\n            , durable: !!this.options.durable\n            , exclusive: !!this.options.exclusive\n            , autoDelete: !!this.options.autoDelete\n            , noWait: false\n            , \"arguments\": this.options.arguments || {}\n            });\n        this.state = \"declare queue\";\n      }\n      break;\n\n    case methods.queueDeclareOk:\n      this.state = 'open';\n      this.name = args.queue;\n      this.connection.queues[this.name] = this;\n\n      // Rebind to previously bound exchanges, if present.\n      // Important this is called *before* openCallback, otherwise bindings will happen twice.\n      // Run test-purge to make sure you got this right\n      _.forEach(this._bindings, function(exchange, exchangeName){\n        _.forEach(exchange, function(count, routingKey){\n          self.bind(exchangeName, routingKey);\n        });\n      });\n\n      // Call opening callback (passed in function)\n      // FIXME use eventemitter - maybe we call a namespaced event here\n      if (this._openCallback) {\n        this._openCallback(this, args.messageCount, args.consumerCount);\n        this._openCallback = null;\n      }\n\n      // TODO this is legacy interface, remove me\n      this.emit('open', args.queue, args.messageCount, args.consumerCount);\n\n      // If this is a reconnect, we must re-subscribe our queue listeners.\n      var consumerTags = Object.keys(this.consumerTagListeners);\n      for (var index in consumerTags) {\n        if (consumerTags.hasOwnProperty(index)) {\n          if (this.consumerTagOptions[consumerTags[index]]['state'] === 'closed') {\n            this.subscribeRaw(this.consumerTagOptions[consumerTags[index]], this.consumerTagListeners[consumerTags[index]]);\n            // Having called subscribeRaw, we are now a new consumer with a new consumerTag.\n            delete this.consumerTagListeners[consumerTags[index]];\n            delete this.consumerTagOptions[consumerTags[index]];\n          }\n        }\n      }\n      break;\n\n    case methods.basicConsumeOk:\n      debug && debug('basicConsumeOk', util.inspect(args, null));\n      break;\n\n    case methods.queueBindOk:\n      if (this._bindCallback) {\n        // setting this._bindCallback to null before calling the callback allows for a subsequent bind within the callback\n        // FIXME use eventemitter\n        var cb = this._bindCallback;\n        this._bindCallback = null;\n        cb(this);\n      }\n      break;\n\n    case methods.queueUnbindOk:\n      break;\n\n    case methods.basicQosOk:\n      break;\n\n    case methods.confirmSelectOk:\n      this._sequence = 1;\n      this.confirm = true;\n      break;\n\n    case methods.channelClose:\n      this.state = \"closed\";\n      this.closeOK();\n      this.connection.queueClosed(this.name);\n      var e = new Error(args.replyText);\n      e.code = args.replyCode;\n      this.emit('error', e);\n      this.emit('close');\n      break;\n\n    case methods.channelCloseOk:\n      this.connection.queueClosed(this.name);\n      this.emit('close');\n      break;\n\n    case methods.basicDeliver:\n      this.currentMessage = new Message(this, args);\n      break;\n\n    case methods.queueDeleteOk:\n      break;\n\n    case methods.basicCancel:\n      this.close(\"Closed due to basicCancel received on consumer (\" + args.consumerTag + \")\");\n      break;\n\n    default:\n      throw new Error(\"Uncaught method '\" + method.name + \"' with args \" +\n          JSON.stringify(args) + \"; tasks = \" + JSON.stringify(this._tasks));\n  }\n\n  this._tasksFlush();\n};\n\n\nQueue.prototype._onContentHeader = function (channel, classInfo, weight, properties, size) {\n  _.assignIn(this.currentMessage, properties);\n  this.currentMessage.read = 0;\n  this.currentMessage.size = size;\n\n  this.emit('rawMessage', this.currentMessage);\n  if (size === 0) {\n    // If the message has no body, directly emit 'end'\n    this.currentMessage.emit('end');\n  }\n};\n\nQueue.prototype._onContent = function (channel, data) {\n  this.currentMessage.read += data.length;\n  this.currentMessage.emit('data', data);\n  if (this.currentMessage.read == this.currentMessage.size) {\n    this.currentMessage.emit('end');\n  }\n};\n\nQueue.prototype.flow = function(active) {\n  var self = this;\n  return this._taskPush(methods.channelFlowOk, function () {\n    self.connection._sendMethod(self.channel, methods.channelFlow, {'active': active });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-amqp/amqp/lib/message.js":"'use strict';\nvar events = require('events'),\n    util = require('util'),\n    fs = require('fs'),\n    protocol,\n    definitions = require('./definitions');\n\n// Properties:\n// - routingKey\n// - size\n// - deliveryTag\n//\n// - contentType (default 'application/octet-stream')\n// - contentEncoding\n// - headers\n// - deliveryMode\n// - priority (0-9)\n// - correlationId\n// - replyTo\n// - experation\n// - messageId\n// - timestamp\n// - userId\n// - appId\n// - clusterId\nvar Message = module.exports = function Message (queue, args) {\n  var msgProperties = definitions.classes[60].fields;\n\n  events.EventEmitter.call(this);\n\n  this.queue = queue;\n\n  this.deliveryTag = args.deliveryTag;\n  this.redelivered = args.redelivered;\n  this.exchange    = args.exchange;\n  this.routingKey  = args.routingKey;\n  this.consumerTag = args.consumerTag;\n\n  for (var i=0, l=msgProperties.length; i<l; i++) {\n    if (args[msgProperties[i].name]) {\n      this[msgProperties[i].name] = args[msgProperties[i].name];\n    }\n  }\n};\nutil.inherits(Message, events.EventEmitter);\n\n\n// Acknowledge receipt of message.\n// Set first arg to 'true' to acknowledge this and all previous messages\n// received on this queue.\nMessage.prototype.acknowledge = function (all) {\n  this.queue.connection._sendMethod(this.queue.channel, definitions.methods.basicAck,\n      { reserved1: 0\n      , deliveryTag: this.deliveryTag\n      , multiple: all ? true : false\n      });\n};\n\n// Reject an incoming message.\n// Set first arg to 'true' to requeue the message.\nMessage.prototype.reject = function (requeue) {\n  this.queue.connection._sendMethod(this.queue.channel, definitions.methods.basicReject,\n      { deliveryTag: this.deliveryTag\n      , requeue: requeue ? true : false\n      });\n};\n\n","/home/travis/build/npmtest/node-npmtest-amqp/amqp/lib/parser.js":"'use strict';\n\nvar events = require('events');\nvar util = require('util');\nvar net = require('net');\nvar tls = require('tls');\nvar fs = require('fs');\nvar debug = require('./debug');\nvar jspack = require('../jspack').jspack;\nvar AMQPTypes = require('./constants').AMQPTypes;\nvar Indicators = require('./constants').Indicators;\nvar FrameType = require('./constants').FrameType;\nvar definitions = require('./definitions');\nvar methodTable = definitions.methodTable;\nvar classes = definitions.classes;\n\n// parser\n\nvar MAX_FRAME_BUFFER_DEFAULT = 131072; // 128k, same as rabbitmq (which was\n                             // copying qpid)\n\n// An interruptible AMQP parser.\n//\n// type is either 'server' or 'client'\n// version is '0-9-1'.\n//\n// Instances of this class have several callbacks\n// - onMethod(channel, method, args);\n// - onHeartBeat()\n// - onContent(channel, buffer);\n// - onContentHeader(channel, class, weight, properties, size);\n//\n// This class does not subclass EventEmitter, in order to reduce the speed\n// of emitting the callbacks. Since this is an internal class, that should\n// be fine.\nvar AMQPParser = module.exports = function AMQPParser (version, type) {\n  this.isClient = (type == 'client');\n  this.state = this.isClient ? 'frameHeader' : 'protocolHeader';\n  this.maxFrameBuffer = MAX_FRAME_BUFFER_DEFAULT;\n\n  if (version != '0-9-1') this.throwError(\"Unsupported protocol version\");\n\n  var frameHeader = new Buffer(7);\n  frameHeader.used = 0;\n  var frameBuffer, frameType, frameChannel;\n\n  var self = this;\n\n  function header(data) {\n    var fh = frameHeader;\n    var needed = fh.length - fh.used;\n    data.copy(fh, fh.used, 0, data.length);\n    fh.used += data.length; // sloppy\n    if (fh.used >= fh.length) {\n      fh.read = 0;\n      frameType = fh[fh.read++];\n      frameChannel = parseInt(fh, 2);\n      var frameSize = parseInt(fh, 4);\n      fh.used = 0; // for reuse\n      if (frameSize > self.maxFrameBuffer) {\n        self.throwError(\"Oversized frame \" + frameSize);\n      }\n      frameBuffer = new Buffer(frameSize);\n      frameBuffer.used = 0;\n      return frame(data.slice(needed));\n    }\n    else { // need more!\n      return header;\n    }\n  }\n\n  function frame(data) {\n    var fb = frameBuffer;\n    var needed = fb.length - fb.used;\n    var sourceEnd = (fb.length > data.length) ? data.length : fb.length;\n    data.copy(fb, fb.used, 0, sourceEnd);\n    fb.used += data.length;\n    if (data.length > needed) {\n      return frameEnd(data.slice(needed));\n    }\n    else if (data.length == needed) {\n      return frameEnd;\n    }\n    else {\n      return frame;\n    }\n  }\n\n  function frameEnd(data) {\n    if (data.length > 0) {\n      if (data[0] === Indicators.FRAME_END) {\n        switch (frameType) {\n        case FrameType.METHOD:\n          self._parseMethodFrame(frameChannel, frameBuffer);\n          break;\n        case FrameType.HEADER:\n          self._parseHeaderFrame(frameChannel, frameBuffer);\n          break;\n        case FrameType.BODY:\n          if (self.onContent) {\n            self.onContent(frameChannel, frameBuffer);\n          }\n          break;\n        case FrameType.HEARTBEAT:\n          debug && debug(\"heartbeat\");\n          if (self.onHeartBeat) self.onHeartBeat();\n          break;\n        default:\n          self.throwError(\"Unhandled frame type \" + frameType);\n          break;\n        }\n        return header(data.slice(1));\n      }\n      else {\n        self.throwError(\"Missing frame end marker\");\n      }\n    }\n    else {\n      return frameEnd;\n    }\n  }\n\n  self.parse = header;\n}\n\n// If there's an error in the parser, call the onError handler or throw\nAMQPParser.prototype.throwError = function (error) {\n  if (this.onError) this.onError(error);\n  else throw new Error(error);\n};\n\n// Everytime data is recieved on the socket, pass it to this function for\n// parsing.\nAMQPParser.prototype.execute = function (data) {\n  // This function only deals with dismantling and buffering the frames.\n  // It delegates to other functions for parsing the frame-body.\n  debug && debug('execute: ' + data.toString('hex'));\n  this.parse = this.parse(data);\n};\n\n/**\n * Set the maximum frame buffer size in bytes. The connection needs to change this\n * if the server responds with a connection tune event where the maxFrameBuffer\n * was changed in the server config.\n *\n * @param maxFrameBuffer the maximum frame buffer size in bytes\n */\nAMQPParser.prototype.setMaxFrameBuffer = function(maxFrameBuffer) {\n  this.maxFrameBuffer = maxFrameBuffer;\n};\n\n// parse Network Byte Order integers. size can be 1,2,4,8\nfunction parseInt (buffer, size) {\n  switch (size) {\n    case 1:\n      return buffer[buffer.read++];\n\n    case 2:\n      return (buffer[buffer.read++] << 8) + buffer[buffer.read++];\n\n    case 4:\n      return (buffer[buffer.read++] << 24) + (buffer[buffer.read++] << 16) +\n             (buffer[buffer.read++] << 8)  + buffer[buffer.read++];\n\n    case 8:\n      return (buffer[buffer.read++] << 56) + (buffer[buffer.read++] << 48) +\n             (buffer[buffer.read++] << 40) + (buffer[buffer.read++] << 32) +\n             (buffer[buffer.read++] << 24) + (buffer[buffer.read++] << 16) +\n             (buffer[buffer.read++] << 8)  + buffer[buffer.read++];\n\n    default:\n      throw new Error(\"cannot parse ints of that size\");\n  }\n}\n\n\nfunction parseShortString (buffer) {\n  var length = buffer[buffer.read++];\n  var s = buffer.toString('utf8', buffer.read, buffer.read+length);\n  buffer.read += length;\n  return s;\n}\n\n\nfunction parseLongString (buffer) {\n  var length = parseInt(buffer, 4);\n  var s = buffer.slice(buffer.read, buffer.read + length);\n  buffer.read += length;\n  return s.toString();\n}\n\n\nfunction parseSignedInteger (buffer) {\n  var int = parseInt(buffer, 4);\n  if (int & 0x80000000) {\n    int |= 0xEFFFFFFF;\n    int = -int;\n  }\n  return int;\n}\n\nfunction parseValue (buffer) {\n  switch (buffer[buffer.read++]) {\n    case AMQPTypes.STRING:\n      return parseLongString(buffer);\n\n    case AMQPTypes.INTEGER:\n      return parseInt(buffer, 4);\n\n    case AMQPTypes.DECIMAL:\n      var dec = parseInt(buffer, 1);\n      var num = parseInt(buffer, 4);\n      return num / (dec * 10);\n\n    case AMQPTypes._64BIT_FLOAT:\n      var b = [];\n      for (var i = 0; i < 8; ++i)\n        b[i] = buffer[buffer.read++];\n\n      return (new jspack(true)).Unpack('d', b);\n\n    case AMQPTypes._32BIT_FLOAT:\n      var b = [];\n      for (var i = 0; i < 4; ++i)\n        b[i] = buffer[buffer.read++];\n\n      return (new jspack(true)).Unpack('f', b);\n\n    case AMQPTypes.TIME:\n      var int = parseInt(buffer, 8);\n      return (new Date()).setTime(int * 1000);\n\n    case AMQPTypes.HASH:\n      return parseTable(buffer);\n\n    case AMQPTypes.SIGNED_64BIT:\n      return parseInt(buffer, 8);\n\n    case AMQPTypes.SIGNED_8BIT:\n      return parseInt(buffer, 1);\n\n    case AMQPTypes.BOOLEAN:\n      return (parseInt(buffer, 1) > 0);\n\n    case AMQPTypes.BYTE_ARRAY:\n      var len = parseInt(buffer, 4);\n      var buf = new Buffer(len);\n      buffer.copy(buf, 0, buffer.read, buffer.read + len);\n      buffer.read += len;\n      return buf;\n\n    case AMQPTypes.ARRAY:\n      var len = parseInt(buffer, 4);\n      var end = buffer.read + len;\n      var arr = [];\n\n      while (buffer.read < end) {\n        arr.push(parseValue(buffer));\n      }\n\n      return arr;\n\n    case AMQPTypes.VOID:\n      return null;\n\n    default:\n      throw new Error(\"Unknown field value type \" + buffer[buffer.read-1]);\n  }\n}\n\nfunction parseTable (buffer) {\n  var length = buffer.read + parseInt(buffer, 4);\n  var table = {};\n\n  while (buffer.read < length) {\n    table[parseShortString(buffer)] = parseValue(buffer);\n  }\n\n  return table;\n}\n\nfunction parseFields (buffer, fields) {\n  var args = {};\n  var bitIndex = 0;\n  var value;\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n\n    //debug && debug(\"parsing field \" + field.name + \" of type \" + field.domain);\n\n    switch (field.domain) {\n      case 'bit':\n        // 8 bits can be packed into one octet.\n\n        // XXX check if bitIndex greater than 7?\n\n        value = (buffer[buffer.read] & (1 << bitIndex)) ? true : false;\n\n        if (fields[i+1] && fields[i+1].domain == 'bit') {\n          bitIndex++;\n        } else {\n          bitIndex = 0;\n          buffer.read++;\n        }\n        break;\n\n      case 'octet':\n        value = buffer[buffer.read++];\n        break;\n\n      case 'short':\n        value = parseInt(buffer, 2);\n        break;\n\n      case 'long':\n        value = parseInt(buffer, 4);\n        break;\n\n      // In a previous version this shared code with 'longlong', which caused problems when passed Date \n      // integers. Nobody expects to pass a Buffer here, 53 bits is still 28 million years after 1970, we'll be fine.\n      case 'timestamp':\n        value = parseInt(buffer, 8);\n        break;\n\n      // JS doesn't support 64-bit Numbers, so we expect if you're using 'longlong' that you've\n      // used a Buffer instead\n      case 'longlong':\n        value = new Buffer(8);\n        for (var j = 0; j < 8; j++) {\n          value[j] = buffer[buffer.read++];\n        }\n        break;\n\n      case 'shortstr':\n        value = parseShortString(buffer);\n        break;\n\n      case 'longstr':\n        value = parseLongString(buffer);\n        break;\n\n      case 'table':\n        value = parseTable(buffer);\n        break;\n\n      default:\n        throw new Error(\"Unhandled parameter type \" + field.domain);\n    }\n    //debug && debug(\"got \" + value);\n    args[field.name] = value;\n  }\n\n  return args;\n}\n\n\nAMQPParser.prototype._parseMethodFrame = function (channel, buffer) {\n  buffer.read = 0;\n  var classId = parseInt(buffer, 2),\n     methodId = parseInt(buffer, 2);\n\n  // Make sure that this is a method that we understand.\n  if (!methodTable[classId] || !methodTable[classId][methodId]) {\n    this.throwError(\"Received unknown [classId, methodId] pair [\" +\n               classId + \", \" + methodId + \"]\");\n  }\n\n  var method = methodTable[classId][methodId];\n\n  if (!method) this.throwError(\"bad method?\");\n\n  var args = parseFields(buffer, method.fields);\n\n  if (this.onMethod) {\n    debug && debug(\"Executing method\", channel, method, args);\n    this.onMethod(channel, method, args);\n  }\n};\n\n\nAMQPParser.prototype._parseHeaderFrame = function (channel, buffer) {\n  buffer.read = 0;\n\n  var classIndex = parseInt(buffer, 2);\n  var weight = parseInt(buffer, 2);\n  var size = parseInt(buffer, 8);\n\n  var classInfo = classes[classIndex];\n\n  if (classInfo.fields.length > 15) {\n    this.throwError(\"TODO: support more than 15 properties\");\n  }\n\n  var propertyFlags = parseInt(buffer, 2);\n\n  var fields = [];\n  for (var i = 0; i < classInfo.fields.length; i++) {\n    var field = classInfo.fields[i];\n    // groan.\n    if (propertyFlags & (1 << (15-i))) fields.push(field);\n  }\n\n  var properties = parseFields(buffer, fields);\n\n  if (this.onContentHeader) {\n    this.onContentHeader(channel, classInfo, weight, properties, size);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-amqp/amqp/lib/constants.js":"module.exports = {\n  AMQPTypes: Object.freeze({\n      STRING:       'S'.charCodeAt(0)\n    , INTEGER:      'I'.charCodeAt(0)\n    , HASH:         'F'.charCodeAt(0)\n    , TIME:         'T'.charCodeAt(0)\n    , DECIMAL:      'D'.charCodeAt(0)\n    , BOOLEAN:      't'.charCodeAt(0)\n    , SIGNED_8BIT:  'b'.charCodeAt(0)\n    , SIGNED_16BIT: 's'.charCodeAt(0)\n    , SIGNED_64BIT: 'l'.charCodeAt(0)\n    , _32BIT_FLOAT: 'f'.charCodeAt(0)\n    , _64BIT_FLOAT: 'd'.charCodeAt(0)\n    , VOID:         'V'.charCodeAt(0)\n    , BYTE_ARRAY:   'x'.charCodeAt(0)\n    , ARRAY:        'A'.charCodeAt(0)\n    , TEN:          '10'.charCodeAt(0)\n    , BOOLEAN_TRUE: '\\x01'\n    , BOOLEAN_FALSE:'\\x00'\n\n })\n , Indicators: Object.freeze({\n    FRAME_END: 206\n })\n , FrameType: Object.freeze({\n      METHOD:    1\n    , HEADER:    2\n    , BODY:      3\n    , HEARTBEAT: 8\n })\n}\n\n"}